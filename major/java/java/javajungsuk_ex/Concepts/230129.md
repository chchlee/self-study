## ✅ Java의 특징
- Java는 객체지향 프로그래밍 언어이다.
- Primitive Type을 제외하고 모든 요소들이 객체로 표현되고, 캡슐화, 상속, 다형성이 잘 적용된 언어이다.
- 장점
    - JVM위에서 동작하기 때문에 운영체제에 독립적이다.
    - GC를 통한 자동적인 메모리 관리가 가능하다.
- 단점
    - JVM위에서 동작하기 때문에 실행속도가 상대적으로 느리다.
    - 다중 상속이나 타입에 엄격하며, 제약이 많다.

## ✅ JVM의 메모리 구조
- JVM은 스택 기반으로 동작하며, Java Byte Code를 OS에 맞게 해석해주는 역할을 하고 가비지컬렉션을 통해 자동적인 메모리 관리를 해준다.
- 응용프로그램이 실행되면, JVM은 시스템으로부터 프로그램을 수행하는데 필요한 메모리를 할당받고 JVM은 이 메모리를 용도에 따라 여러 영역으로 나누어 관리한다. 

1. 메서드 영역
    - 프로그램 실행 중 어떤 클래스가 사용되면, JVM은 해당 클래스의 클래스파일을 읽어 분석하여 클래스에 대한 정보를 이곳에 저장한다. 이 때, 그 클래스의 클래스변수도 이 영역에 함께 생성된다.
2. 힙(heap)
    - 인스턴스가 생성되는 공간, 프로그램 실행 중 생성되는 인스턴스는 모두 이곳에 생성된다. 즉, 인스턴스 변수들이 생성되는 공간이다.
3. 호출스택(call stack 또는 excution stack)
    - 호출스택은 메서드의 작업에 필요한 메모리 공간을 제공한다. 메서드가 호출되면, 호출스택에 호출된 메서드를 위한 메모리가 할당되며, 이 메모리는 메서드가 작업을 수행하는 동안 지역변수들과 연산의 중간결과 등을 저장하는데 사용된다. 그리고 메서드가 작업을 마치면 할당되었던 메모리공간은 반환되어 비워진다.

<p align="center"><img src="https://img1.daumcdn.net/thumb/R800x0/?scode=mtistory2&fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F22647237574FF66B28" ></img></p>


## ✅ Java의 컴파일 과정
1. 개발자가 .java 파일을 생성한다.
2. build를 한다.
3. java compiler의 javac 명령어를 통해 바이트코드를(*.class) 생성한다.
4. class loader를 통해 JVM내 메모리 내로 로드한다.
5. 실행엔진을 통해서 컴퓨터가 읽을 수 있는 기계어로 해석된다.
<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcgGf08%2Fbtrup9tFZNc%2FdfbotBKGFrZ4mDGIYrNj10%2Fimg.png"></img>

## ✅ 오버라이딩 vs 오버로딩
- 오버라이딩은 상위 클래스에 있는 메소드를 하위 클래스에 재정의 하는 것을 말한다.
- 오버로딩은 매개변수나 타입을 다르게 하여 같은 이름의 메소드를 여러 개 정의하는 것을 말한다.

## ✅ 추상클래스 vs 인터페이스
- 추상 클래스는 클래스 내 추상 메소드가 하나 이상 포함되거나 abstract로 정의된 것을 말한다.
- 인터페이스는 모든 메소드가 추상 메소드로만 이루어져 있는 것을 말한다.
- 공통점
    - new 연산자로 인스턴스 생성 불가능
    - 사용하기 위해서는 하위 클래스에서 확장/구현 해야한다.
- 차이점
    - 인터페이스는 그 인터페이스를 구현하는 모든 클래스에 대해 특정한 메소드가 반드시 존재하도록 강제함에 있다.
    - 추상클래스는 상속받는 클래스들의 공통적인 로직을 추상화 시키고, 기능 확장을 위해 사용한다.
    - 추상클래스는 다중 상속이 불가능하지만, 인터페이스는 다중 상속이 가능하다.

## ✅ 가비지 컬렉션의 과정에 대해 설명해주세요
- GC의 작업을 수행하기 위해 JVM이 어플리케이션의 실행을 잠시 멈추고, GC를 실행하는 쓰레드를 제외한 모든 쓰레드들의 작업을 중단 후 사용하지 않는 메모리를 제거하고 작업이 재개됩니다.

## ✅ 객체지향의 설계 원칙에 대해 설명해주세요
1. SRP(Single Responsibility Principle) : 단일 책임 원칙
    - 한 클래스는 하나의 책임만 가져야 한다.
        - 모든 클래스는 각각 하나의 책임만 가져야 하며, 수정할 이유는 단 한가지여야 한다.
        즉, 클래스는 그 책임을 완전히 캡슐화해야 함을 말한다.
        예를들어, 결제 클래스가 있다고 하면, 이 클래스는 오직 결제 기능만을 책임지고,
        만약 이 클래스를 수정해야 한다면 결제에 관련된 문제일 뿐일 것이다.
<br/>
2. OCP(Open-Closed Principle) : 개방 폐쇄 원칙
    - 소프트웨어의 구성요소는 확정에는 열려 있어야 하지만 변경에는 폐쇄적이여야 함을 의미한다.
    - 즉, 기존의 코드를 변경하지 않으면서, 기능을 추가할 수 있도록 설계가 되는 원칙을 말한다.
        - 예를들어, 캐릭터 하나를 생성한다고 할 떄 각 캐릭터마다 움직임이 다를 경우,
        움직임 패턴 구현을 하위클래스에 맡긴다면 캐릭터 클래스의 수정은 필요없고(Closed),
        움직임 패턴만 재정의 하면 된다.
        - 개방-폐쇄 원칙을 적용하기 위한 중요 매커니즘은 추상화와 다형성이다.
<br/>
3. LSP(Liskov Substuitution Principle) : 리스코프 치환 원칙
    - 서브 타입은 언제나 자신의 기반 타입으로 변경할 수 있어야 한다.
    - 상위 타입은 항상 하위 타입으로 대체할 수 있어야 함을 의미한다.
    - 즉, 부모 클래스가 들어갈 자리에 자식 클래스를 넣어도 역할을 하는데 문제가 없어야 한다는 의미이다.
    - 예를 들어, 할아버지가 Super 클래스이고, 아버지, 삼촌이 Sub 클래스 일 때는 리스코프 치환 원칙에 
    위배되지만, 동물이 Super 클래스이고, 포유류, 조류가 Sub 클래스 일 경우에 리스코프 치환 원칙을
    준수한다고 할 수 있다고 할 수 있다.
    - 리스코프 치환 원칙은 다형성과 확장성을 극대화하며, 개방-폐쇄 원칙을 구성한다.
<br/>
4. ISP(Interface Segregation Principle) : 인터페이스 분리 원칙
    - 인터페이스 분리 원칙은 각 역할에 맞게 인터페이스를 분리하라는 것이다.
    - 인터페이스 내에 메소드를 최소한 일수록 좋다. 즉, 최소한의 기능만 제공하면서 하나의 역할에 집중하라는 뜻이다.
    - 가능한 최소한의 인터페이스를 사용하도록 하여 단일 책임을 강조한다고 볼 수 있다.
<br/>
5. DIP(Depedency Inversion Principle) : 의존관계 역전 원칙
    - 구체적인 클래스보다 상위 클래스, 인터페이스, 추상 클래스와 같이 변하지 않을 가능성이 높은 클래스와 관계를 맺으라는 것이다.
<br/>

## ✅ 컬렉션 프레임워크란
- 배열의 문제점을 해결하기 위해, 널리 알려져 있는 자류구조를 바탕으로 객체나 데이터 들을 효율적으로 관리할 수 있는 자료구조이다.

|인터페이스|설명|구현클래스|
|--|--|--|
|List\<E>|순서가 있는 데이터의 집합 <br> 데이터의 중복을 허용함.|Vector, ArrayList, LinkedList <br> Stack, Queue|
|Set\<E>|순서가 없는 데이터의 집합 <br> 데이터의 중복을 허용하지 않음.|HashSet, TreeSet|
|Map\<K,V>|키와 값이 한 쌍으로 이루어진 데이터로 집합 순서가 없음. <br>키는 중복을 허용하지 않고 값은 중복 허용|HaspMap, TreeMap <br> HashTable, Properties|



### - List 컬렉션
- List 컬렉션은 객체를 일렬로 늘어놓은 구조를 가지고 있다.
- 객체를 인덱스로 관리하기 때문에 객체를 저장하면 자동 인덱스가 부여되고 인덱스로 객체를 검색, 삭제할 수 있는 기능을 제공한다.
- List 컬렉션은 객체 자체를 저장하는 것이 아니라 위와 같이 객체의 번지를 참조한다.
- 동일한 객체를 중복 저장할 수 있는데 동일한 번지가 참조된다. null도 저장이 가능한데, 이 경우 해당 인덱스는 객체를 참조하지 않는다.
<p align="center"><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbqtJXz%2Fbtq4s21iCUF%2FQO2CN4Y31P0gLV2mdZGAg0%2Fimg.png"></img></p>


### - Set 컬렉션
- Set 컬렉션은 저장 순서가 유지 되지 않는다.
- 또한 객체를 중복해서 저장할 수 없고, 하나의 null만 저장할 수 있다.
- 그렇기에 Set 컬렉션은 순서 자체가 없으므로 인덱스로 객체를 검색해서 가져오는 get(index) 메소드도 없다.
- 대신 전체 객체를 대상으로 한 번씩 반복해서 가져오는 반복자(Iterator)를 제공한다.
<p align="center"><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FYW1Gm%2Fbtq4vSjDjb6%2Fgb3vKCNW8N5hpmeu47es70%2Fimg.png"></img></p>


### - Map 컬렉션
- Map 컬렉션은 Key와 Value로 구성된 객체를 저장하는 구조이다.
- 키는 중복 저장될 수 없지만 값은 중복저장 될 수 있으며 중복된 key 값이 들어온다면 기존의 값은 없어지고 새로운 값으로 대치된다.
- Map은 리스트나 배열처럼 순차적으로 해당 요소 값을 구하지 않고, 키를 통해 값을 얻는게 큰 특징이다.
<p align="center"><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbCWIJc%2Fbtq4rcDnp4s%2FkX7USSMnz9Ax55midNTfHK%2Fimg.png"></p>
    