## 1. 상속(inheritance)
### 1.1 상속의 정의와 장점

- 상속이란, 기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것이다. 만약 부모 클래스를 상속받은 자식 클래스가 있을경우 별도의 선언 없이 부모 클래스의 멤버를 사용 가능하다.


### 1.2 포함관계
- 클래스 간의 포함관계를 맺어 주는 것은 한 클래스의 멤버변수로 다른 클래스 타입의 참조변수를 선언하는 것을 뜻한다.

## 2. 오버라이딩
- 조상 클래스로부터 상속받은 메서드의 내용을 변경하는 것을 오버라이딩(overriding)이라 한다.

### 2.2 오버라이딩의 조건
자손 클래스에서 오버라이딩 하는 메서드는 조상 클래스의 메서드와
- 이름이 같아야 한다.
- 매개변수가 같아야 한다.
- 반환타입이 같아야 한다.

### 2.4 super
- super는 자손 클래스에서 조상 클래스로부터 상속받은 멤버를 참조하는데 사용되는 참조 변수이다. 멤버변수와 지역변수의 이름이 같을 때 this를 붙여서 구별했듯이 상속받은 멤버와 자신의 멤버와 이름이 같을 때는 super를 붙여서 구별할 수 있다.(참조변수 super)

### 2.5 super() - 조상클래스의 생성자
- this()와 마찬가지로 super() 역시 생성자이다. super()는 조상 클래스의 생성자를 호출하는데 사용된다.
- 생성자의 첫 줄에서 조상클래스의 생성자를 호출해야하는 이유는 자손 클래스의 멤버가 조상 클래스의 멤버를 사용할 수도 있으므로 조상의 멤버들이 먼저 초기화되어 있어야 하기 때문이다.

인스턴스를 생성할 떄는 클래스를 선택하는 것만큼 생성자를 선택하는 것도 중요하다.
```txt
1. 클래스 - 어떤 클래스의 인스턴스를 생성할 것인가?
2. 생성자 - 선택한 클래스의 어떤 생성자를 이용하여 인스턴스를 생성할 것인가?
```

조상 클래스의 멤버변수는 조상 생성자에 의해 초기화되도록 해야한다.

## 4. 제어자
### 4.5 접근제어자
접근 제어나는 멤버 또는 클래스에 사용되어, 해당하는 멤버 또는 클래스를 외부에서 접근하지 못하도록 제한하는 역할을 한다.
접근 제어자가 default임을 알리기 위해 실제로 default를 붙이지는 않는다. 클래스나 멤버변수, 메서드 , 생성자에 접근제어자가 지정되어 있지 않다면, 접근 제어자가 default임을 뜻한다.

- private : 같은 클래스 내에서만 접근이 가능하다.
- default : 같은 패키지 내에서만 접근이 가능하다.
- protected : 같은 패키지 내에서, 그리고, 다른 패키지의 자손클래스에서 접근이 가능하다.
- public : 접근 제한이 전혀 없다.

클래스나 멤버, 주로 멤버에 접근 제어자를 사용하는 이유는 클래스의 내부에 선언된 데이터를 보호하기 위해서이다. 데이터가 유효한 값을 유지하도록, 또는 비밀번호와 같은 데이터를 외부에서 함부로 변경하지 못하도록 하기 위해서는 외부로부터의 접근을 제한하는 것이 필요하다.

## 5. 다형성
### 5.1 다형성이란?
객체지향개념에서 다형성이란 '여러 가지 형태를 가질 수 있는 능력'을 의미하며, 자바에서는 한 타입의 참조변수로 여러 타입의 객체를 참조할 수 있도록 함으로써 다형성을 프로그램적으로 구현하였다.
이를 좀 더 구체적으로 말하자면, 조상클래스 타입의 참조변수로 자손클래스의 인스턴스를 참조할 수 있도록 하였다는 것이다.

```java
조상타입의 참조변수로 자손타입의 인스턴스를 참조할 수 있다.
Tv t = new SamsungTv();

반대로 자손타입의 참조변수로 조상타입의 인스턴스를 참조할 수는 없다.
SamsungTv st = new Tv(); // X 자손타입의 참조변수로 조상타입의 인스턴스 참조불가.

```

### 5.2 참조변수의 형변환
기본형 변수와 같이 참조변수도 형변환이 가능하다. 단, 서로 상속관계에 있는 클래스 사이에서만 가능하다.

```java
자손타입 -> 조상타입(Up-Casting) : 형변환 생략가능
자손타입 <- 조상타입(Down-Casting) : 형변환 생략불가

조상인 Object 타입의 참조변 로 형변환 하는것은 참조변수가 다룰 수 있는 멤버의 개수가 실제 인스턴스가 갖 고있는 멤버의 개수보다 적을 것이 분명하므로 문제가 되지 않는다.

Car car = null;
FireEngine fe = new FireEngine();
FireEngine fe2 = null;

car = fe; // 업캐스팅. 형변환 생략가능
fe2 = (FireEngine)car; // 다운캐스팅. 형변환 생략불가능

형변환은 참조변수의 타입을 변환하는 것이지 인스턴스를 변환하는 것은 아니기 때문에
참조변수의 형변환은 인스턴스에 아무런 영향을 미치지 않는다.
```

### 5.3 instanceof 연산자
참조변수가 참조하고 있는 인스턴스의 실제 타입을 알아보기 위해 instanceof 연산자를 사용한다.
instanceof의 왼쪽에는 참조변수를 오른쪽에는 타입(클래스명)이 피연산자로 위치한다.
어떤 타입에 대한 instanceof 연산의 결과가 true 라는 것은 검사한 타입으로 형변환이 가능하다는 것을 뜻한다.

### 5.5 매개변수의 다형성

참조변수의 다형적인 특징은 메서드의 매개변수에도 적용된다. 아래와 같이 Product, Tv, Computer, Audio, Buyer 클래스가 정의되어 있다고 가정하자.


```java
class Product {
    int price;
    int bonusPoint;
}

class Tv extends Product {}
class Computer extends Product {}
class Audio extends Product {}

class Buyer {
    int money = 1000;
    int bonusPoint;
}
```

Buyer 클래스에 물건을 구입하는 기능의 메서드를 추가해보자. 구입할 대상이 필요하므로 매개변수로 구입할 제품을 넘겨 받아야한다. 하지만, 제품의 종류가 늘어날 때마다 Buyer 클래스에는 새로운 buy 메소드를 오버로딩 해줘야 한다.
그러나 메서드의 매개변수에 다형성을 적용하면 아래와 같이 하나의 메서드로 간단히 처리할 수 있다.

```java
void buy(Product p){
    money = money -= p.price;
    bonusPoint = bonusPoint + p.bonusPoint;;
}
```

## 6. 추상클래스
클래스를 설계도에 비유한다면, 추상클래스는 미완성 설계도에 비유할 수 있다.
미완성 설계도로 완성된 제품을 만들 수는 없듯이 추상클래스로 인스턴스는 생성할 수 없다.(단, 추상클래스를 이용해 배열 객체를 만들어 내는 것은 가능하다.) 추상클래스는 자손클래스에 의해서만 완성될 수 있다.

## 7. 인터페이스
### 7.1 인터페이스란?
인터페이스는 일종의 추상클래스이다. 인터페이스는 추상클래스처럼 추상메서드를 갖지만 추상클래스보다 추상화 정도가 높아서 추상클래스와 달리 몸통을 갖춘 일반 메서드 또는 멤버변수를 구성원으로 가질 수 없다. 오직 추상메서드와 상수만을 멤버로 가질 수 있으며, 그 외의 다른 어떠한 요소도 허용하지 않는다.

### 7.1.1 인터페이스와 추상클래스의 차이
인터페이스는 추상클래스와 달리 일반 메서드나 멤버변수를 구성원으로 가질 수 없다.

### 7.2 인터페이스의 작성
인터페이스를 작성하는 것은 클래스를 작성하는 것과 같다. 다만 키워드로 class 대신 interface를 사용하다는 것만 다르다. 그리고 interface에도 클래스와 같이 접근제어자로 public 또는 default를 사용할 수 있다.

```java
interaface 인터페이스명{
    public static final 타입 상수이름 = 값;
    public abstract 메서드이름(매개변수 목록);
}
```
### 7.3 인터페이스의 상속
인터페이스는 인터페이스로부터만 상속받을 수 있으며, 클래스와는 달리 다중상속, 즉 여러 개의 인터페이스로부터 상속을 받는 것이 가능하다.

인터페이스는 클래스와 달리 Object클래스와 같은 최고 조상이 없다.

### 7.4 인터페이스의 구현
인터페이스도 추상클래스처럼 그 자체로는 인스턴스를 생성할 수 없다.

### 7.6 인터페이스를 이용한 다형성
인터페이스의 참조변수로 이를 구현한 클래스의 인스턴스를 참조할 수 있으며, 인터페이스 타입으로 형변환도 가능하다.
따라서 인터페이스는 다음과 같이 메서드의 매개변수의 타입으로 사용될 수 있다.

```java
void attack(Fightable f){
    //...
}
```

인터페이스 타입의 매개변수가 갖는 의미는 메서드 호출 시 해당 인터페이스를 구현한 클래스의 인스턴스를 매개변수로 제공해야 한다는 것이다.
그래서 attack 메서드를 호출할 때는 매개변수로 Fightable인터페이스를 구현한 클래스의 인스턴스를 넘겨주어야 한다.

```java
class Fightable extends Unit implements Fightable {
    public void move(int x, int y){ }
    public void attack(Fightable f){ }
}
```

### 7.8 인터페이스의 이해
인터페이스를 더욱 잘 이해하기 위해서는 다음의 두 가지 사항을 반드시 염두에 두고 있어야 한다.
- 클래스를 사용하는 쪽(User)과 클래스를 제공하는 쪽(Provider)이 있다.
- 메서드를 사용(호출)하는 쪽(User)에서는 사용하려는 메서드(Provider)의 선언부만 알면 된다.