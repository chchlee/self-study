## 3.1 HTTP 메시지
HTTP에서 교환하는 정보는 HTTP 메시지라 불리는데 리퀘스트 측 HTTP 메시지를 리퀘스트 메시지, 리스폰스 측 HTTP 메시지를 리스폰스 메시지라 부른다.
HTTP 메시지는 복수 행(CR+LF)의 데이터로 구성된 텍스트 문자열이다. HTTP 메시지는 크게 구분하면 메시지 헤더와 메시지 바디로 구성 되어 있고, 최초에 나타내는 계행 문자(CR + LF)로 메시지 헤더와 메시지 바디를 구분한다. 이 안에 바디가 항상 존재한다고 할 수 없다.

- CR(Carriage Return) : 16진수 0x0d
- LF(Line Feed) : 16진수 0x0a

<div align="center">
<img src="https://user-images.githubusercontent.com/97272787/223376730-f77b414b-2045-4f8d-aed9-9ad51c47287d.png">
</div>

## 3.2 리퀘스트 메시지와 리스폰스 메시지의 구조
<div align="center">
<img src="https://user-images.githubusercontent.com/97272787/223377060-8a68e3f3-96f2-40e8-be7a-6ba2eab78675.png">
</div>

```http
GET / HTTP/1.1
HOST: developer.mozila.org
AcceptLanguage: fr
```

<div align="center">
<img src="https://user-images.githubusercontent.com/97272787/223377652-68da2e74-0c2e-48ef-8fdd-c7fd85e30742.png">
</div>

- 리퀘스트 라인
     - 리퀘스트에 사용되는 메소드와 리퀘스트 URI에 사용하는 HTTP 버전이 포함되어 있다.

- 상태 라인
    - 리스폰스 결과를 나타내는 상태코드와 설명, 사용하는 HTTP 버전이 포함 된다.

- 헤더 필드
    - 리퀘스트와 리스폰스의 여러 조건과 속성 등을 나타내는 각종 헤더 필드가 포함된다.

- 그 외
<div align="center">
<img src="https://user-images.githubusercontent.com/97272787/223378761-10814c67-beb5-427c-bc7c-24c6ab845638.png">
</div>

## 3.3 인코딩으로 전송 효율을 높이다
HTTP로 데이터를 전송할 경우 그대로 전송할 수도 있지만 전송할 때에 인코딩(변환)을 실시함으로써 전송 효율을 높일 수 있다.
전송할 때 인코딩을 하면 다량의 액세스를 좋게 처리할 수 있다. 단지, 컴퓨터에서 인코딩 처리를 해야하기 때문에 CPU 등의 리소스는 보다 많이 소비하게 된다!

### 3.3.1 메시지 바디와 엔티티 바디의 차이
- 엔티티(entity)
    - 리퀘스트랑 리스폰스의 페이로드(payload)로 전송되는 엔티티 헤더 필드와 엔티티 바디로 구성된다.
- 메시지(message)
    - HTTP 통신의 기본 단위로 옥텟 시퀀스(8비트)로 구성되고 통신을 통해서 전송된다.


HTTP 메시지 바디의 역할은 리퀘스트와 리스폰스에 관한 엔티티 바디를 운반하는 일이다. 기본적으로 메시지 바디와 엔티티 바디는 같지만 전송 코딩이 적용된 경우에는 엔티티 바디의 내용이 변화하기 떄문에 메시지 바디와 달라진다.

### 3.3.2 압축해서 보내는 콘텐츠 코딩
HTTP에는 전송시 보내는 메시지의 용량을 줄이기 위해 콘텐츠 코딩(Contents Codings)라는 기능이 구현되어 있다.
콘텐츠 코딩은 엔티티에 적용하는 인코딩을 가리키는데 엔티티 정보를 유지한 채로 압축한다. 콘텐츠 코딩된 엔티티는 수신한 클라이언트 측에서 디코딩하게 된다.

<div align="center">
<img src="https://user-images.githubusercontent.com/97272787/223380252-1234042c-0d78-480d-ad81-853232b4d8ca.png">
</div>

- 주요 압축 콘텐츠
    - gzip(GNU zip)
    - compress(UNIX 표준압축)
    - deflate(zlib)
    - identity(인코딩 없음)

### 3.3.3 분해해서 보내는 청크 전송 코딩
HTTP 통신에서는 리퀘스트 했었던 리소스 전부에서 엔티티 바디의 전송이 완료되지 않으면 브라우저에 표시되지 않는다. 사이즈가 큰 데이터를 전송하는 경우에 데이터를 분할해서 조금씩 표시할 수 있다.
이렇게 엔티티 바디를 분할하는 기능을 청크 전송 코딩(Chunked transfer Coding)이라 한다.

청크 전송 코딩은 엔티티 바디를 청크(덩어리)로 분해한다. 다음 청크 사이즈를 16진수로 사용해서 단락을 표시하고 엔티티 바디 끝에는 "0(CR+LF)"를 기록해둔다.
청크 전송 코딩된 엔티티 바디는 수신한 클라이언트 측에서 원래의 엔티티 바디로 디코딩한다. HTTP/1.1 에는 전송 코딩(Transfer Codings)이라는, 어떤 코딩 방식에 따라서 전송하는 구조가 마련되어 있지만 전송 코딩에는 청크 전송 코딩만 정의되어 있다.

## 3.4 여러 데이터를 보내는 멀티 파트
HTTP에는 멀티파트에 대응하고 있어 하나의 메시지 바디 내부에 엔티티를 여러 개 포함시켜 보낼 수 있다. 주로 이미지나 텍스트 파일 등을 업로드할 때 사용된다.

- 멀티 파트의 종류
    - multipart/form-data
    - mulpart/byteranges
    - multipart/form-data
    - multipart/byteranges

HTTP 메시지로 멀티파트를 사용할 때에는 Content-Type 헤더 필드를 사용한다.
멀티파트 각각의 엔티티를 구분하기 위해 "boundary"문자열을 사용한다.
각 엔티티의 선두에는 "boundary"문자열 앞에 "--"를 삽입한다.
멀티파트 마지막에는 그 문자열의 마지막 부분에 "--"를 삽입해서 마무리 한다.
멀티파트는 파트마다 헤더 필드가 포함된다. 또한 파트의 중간에 멀티파트를 만드는 것과 같이 파트를 내부에 포함할 수도 있다.

## 3.5 일부분만 받는 레인지 리퀘스트
요즘처럼 사용자가 광대역의 네트워크를 이용할 수 있기 전에는 대용량의 이미지와 데이터를 다운로드하기 힘들었다.
왜냐하면 다운로드 중에 커넥션이 끊어지게 되면 처음부터 다시 다운로드를 해야 했기 때문.
이러한 문제를 해결하기 위해 일반적인 리줌(resume)이라는 기능이 필요하게 되었다. 리줌을 통해 이전에 다운로드를 한 곳에서부터 다운로드를 재개할 수 있게 되었다.
이 기능을 실현하기 위해서는 엔티티의 범위를 지정해서 다운로드를 할 필요가 있다. 이와 같이 범위를 지정해서 리퀘스트를 하는 것을 레인지 리퀘스트(Range Request)라 부른다.

레인지 리퀘스트를 사용하면 전체 10,000 바이트 정도 크기의 리소스에서 5,001 ~ 10,000 바이트 범위(바이트 레인지) 만을 리퀘스트 할 수 있다.

<div align="center">
<img src="https://user-images.githubusercontent.com/97272787/223380252-1234042c-0d78-480d-ad81-853232b4d8ca.png">
</div>

레인지 리퀘스트를 할 때에는 Range 헤더 필드를 사용해서 리소스의 바이트 레인지를 지정한다.

- 5,001 ~ 10,000 바이트
```html
Range: bytes = 5001-10000
```

- 5,001 바이트 이상
```html
Range: bytes = 5001-
```

- 처음부터 3,000 바이트 까지, 그리고 5,000 ~ 7,000 바이트까지의 복수 범위
```html
Range: bytes = -3000, 5000-7000
```

레인지 리퀘스트에 대한 리스폰스는 상태 코드 206 Partial Content 라는 리스폰스 메시지가 되돌아온다. 또한, 복수 범위의 레인지 리퀘스트에 대한 리스폰스는 multipart/byteranges로 리스폰스가 되돌아온다.
서버가 레인지 리퀘스트에 지원하지 않는 경우에는 상태 코드 200 OK라는 리스폰스 메시지로 완전한 엔티티가 되돌아온다.

## 3.6 최적의 콘텐츠를 돌려주는 콘텐츠 네고시에이션
같은 콘텐츠(내용)이지만 여러 개의 페이지를 지닌 웹 페이지가 있다. 예를 들면, 내용은 같지만 영어판과 한국어판과 같이 표시되는 언어가 서로 다른 웹 페이지의 경우
이러한 웹 페이지에서는 영어와 한국어가 같이 서로 다른 언어를 주로 사용하는 브라우저가 같은 URI에 액세스할 때에는 각각 영어판 웹 페이지와 한국어판 웹 페이지를 표시한다. 이와 같은 구조를 콘텐츠 네고에이션(Content Negotiation) 이라고 부른다.

<div align="center">
<img src="https://user-images.githubusercontent.com/97272787/223389457-e019de26-8259-4fd0-bb0d-ff915f023a62.png">
</div>

콘텐츠 네고에이션이란 클라이언트와 서버가 제공하는 리소스의 내용에 대해서 교섭하는 것이다. 클라이언트에 더욱 적합한 리소스를 제공하기 위한 구조.
콘텐츠 네고에이션은 제공하는 리소스를 언어와 문자 세트, 인코딩 방식 등을 기준으로 판단하고 있다.
판단 기준은 리퀘스트 메시지에 포함된 다음과 같은 리퀘스트 헤더 필드이다.

- Accept
- Accept-Charset
- Accept-Encoding
- Accept-Language
- Content-Language

콘텐츠 네고시에이션에는 다음과 같은 종류들이 있다.
- 서버 구동형 네고시에이션(Server-driven Negotiation)
    - 서버 측에서 콘텐츠 네고시에이션을 하는 방식이다. 서버 측에서 리퀘스트 헤더 필드의 정보를 참고해서 자동적으로 처리를 한다. 단지, 브라우저가 보내는 정보를 근거로 하기 때문에 신뢰성은 없다.
- 에이전트 구동형 네고시에이션(Agent-driven Negotiation)
    - 클라이언트 측에서 콘텐츠 네고에이션을 하는 방식. 브라우저에 표시된 선택지 중에서 유저가 수동으로 선택한다. 예를 들면, OS의 종류나 브라우저 종류 등에 의해서 PC용과 스마트폰용의 웹 페이지를 자동으로 전환하는 것이 이에 해당한다.
- 트랜스페어런트 네고시에이션(Transparent Negotiation)
    - 서버 구동현과 에이전트 구동형을 혼합한 것으로 서버와 클라이언트가 각각 콘텐츠 네고시에이션을 하는 방식이다.