## 2.1. 웹 애플리케이션

서블릿을 사용하기 전에는 웹서버에서 외부 프로그램을 호출하고, 수행 결과를 웹 브라우저로 전송하는 CGI(Common Gateway Interface)라는 기술을 사용한다. 그러나, CGI 기술은 동시 접속자가 많아질수록 처리 효율이 떨어지는 단점이 있어 이에 대안으로 나온것이 `서블릿(Servlet)`이다.
서블릿을 만드는 목적은 클라이언트에 서비스하기 위해서.

### 2.1.1. 웹 애플리케이션 접근

`서블릿은 웹서버에서 서비스되는 페이지`. 그래서 서블릿을 개발했으면 해당 서블릿 실행 파일을 웹서버에 올려두어야 한다.

<div align="center">
<img src="https://user-images.githubusercontent.com/97272787/229391572-871d0881-c144-463b-9830-aba3676575cc.png">
</div>

1. IP가 `70.12.220.93`인 컴퓨터를 찾아간다.(웹서버가 설치된 pc찾기)
2. `8080`포트를 사용하고 있는 서버를 찾아간다.(pc에서 웹서버 찾기)
3. `edu` 라는 이름의 웹 애플리케이션을 찾아간다. (/edu, 웹서버에 있는 파일찾기)
4. `/index.jsp` 애플리케이션을 찾은 다음에는 해당 애플리케이션에 서비스하는 문서를 찾아야 한다.

클라이언트가 URL의 컴퓨터 주소와 포트 번호를 이용해 웹서버까지 찾았다면 다음 목적지는 웹 애플리케이션이다. 웹 서버가 클라이언트에 서비스하는 단위는 웹 애플리케이션이다. 그래서 개발할 때 먼저 웹 애플리케이션을 생성한 후, 그 안에 서비스하고자 하는 파일들을 작성한다. 그리고 작성된 파일을 실행하려면 파일이 포함된 웹 애플리케이션을 웹서버에 올린 후 서비스를 요청한다.

// 톰캣은 war 확장자로 묶인 녀석들을 구동시킬 수도 있고, 압축이 풀린 상태로도
// 구동시킬 수 있다.

### 2.1.2. 웹 애플리케이션의 위치

톰캣을 설치한 디렉터리 하위의 `webapps` 디렉터리에 애플리케이션들이 있는데, 여기서 `webapps`디렉터리에 있는 하위 디렉터리 또는 디렉터기 압축된 war 파일은 하나의 애플리케이션으로 인식한다.

<div align="center">
<img src="https://user-images.githubusercontent.com/97272787/229517355-f9334a28-9471-4e69-9b65-fd8195df8135.png">
</div>

위 그림은 5개의 애플리케이션을 서비스하고 있다고 볼 수 있다.

### 2.1.3. 웹 애플리케이션의 구조

<div>
<img src="https://user-images.githubusercontent.com/97272787/229392711-babc8556-d196-40dd-99ee-1423f8b593ce.png">
</div>

웹 애플리케이션은 디렉터리나 디렉터리가 압축된 형태로 웹 서버에 올려서 서비스하는데, 이떄 웹 애플리케이션이 서비스 되는 공통 구조는 위 그림과 같다.

웹 애플리케이션은 하나의 디렉터리이다. 이 디렉터리 안에 서비스하려는 문서들을 만들어놓으면 웹에서 서비스되는 것이다. 그런데 반드시 웹 애플리케이션이 공통으로 가져야 하는 디렉터리와 파일들이 IntelliJ의 `WEB-INF` 디렉터리에 있다. 그리고 WEB-INF 디렉터리에는 web.xml 파일이 있어야 한다.
또한, 웹 애플리케이션이 서비스하려는 클래스 파일이 있다면 `WEB-INF/classes` 디렉터리 하위에 있어야 한다. 그리고 클래스 파일들이 jar로 압축되어 있다면 `WEB-INF/lib` 디렉터리에 있어야 한다. 그 이유는, 클래스 파일들이 `WEB-INF/classes` 또는 `WEB-INF/lib` 에 있어야만 WAS를 구성하는 애플리케이션 서버들이 자동으로 인식할 수 있기 때문이다.

### 2.1.4 web.xml

웹서버가 서비스를 시작하기 위해 구동할 때 서버에서 많은 일이 일어난다. 그중의 하나가 클라이언트에 서비스하기 위한 웹 애플리케이션을 준비하는 작업이다.이때 웹서버는 각 웹 애플리케이션의 `web.xml` 파일을 읽는다. `web.xml` 은 웹 애플리케이션의 서비스 처리에 관한 내용이 정의된 파일이다. 웹서버는 `web.xml` 에 정의된 내용대로 웹 애플리케이션을 실행하기 위한 설정을 수행한다.

- `한줄요약` : `web.xml`은 웹 애플리케이션 실행에 관해 정의하는 환경설정 파일.

### 2.1.5 서블릿 디렉터리

서블릿 디렉터리는 `WEB-INF/classes`이다. 서블릿 프로그램 실행에 관련된 클래스 파일들은 이 디렉터리에 있어야만 서블릿 컨테이너가 인식하여 실행한다.

## 2.2 서블릿 구현

웹 브라우저에서 클라이언트의 요청에 따라 서버가 실행할 수 있는 자바 프로그램은 `서블릿 밖에 없다.` 이 말은 오직 서블릿만이 웹에서 동작하는 특별한 조건을 가지고 있다는 의미가 된다.

### 2.2.2. 서블릿 클래스 간의 관계

`HttpServlet`에는 웹 상에서 클라이언트 요청이 있을 때 해당 서블릿을 실행하는 모든 조건이 포함되어 있다.

<div align="center">
<img src="https://user-images.githubusercontent.com/97272787/229394865-6eb8cb4c-1c47-4002-ba5d-6566483242bf.png">
</div>

#### Servlet 인터페이스

Servlet 인터페이스는 서블릿 프로그램을 개발할 때 반드시 구현해야 하는 메소드를 선언하고 있는 인터페이스이다. init(), service(), destroy(), getServletConfig(), getServletInfo() 등 5개의 메소드를 선언하고 있는데, 이는 서블릿 프로그램 실행의 생명주기와 연관된 메소드들이다.

#### GenericServlet 인터페이스

GenericsServlet은 Servlet 인터페이스를 상속하여 클라이언트-서버 환경에서 애플리케이션으로서 필요한 기능을 구현한 추상 클래이다. service() 메소드를 제외한 모든 메소드를 재정의하여 적절한 기능으로 구현하였다.

#### HttpServlet 클래스

HttpServlet 클랫그는 GenericServlet 클래스를 상속하여 service() 메소드를 재정의함으로써 HTTP 프로토콜에 알맞는 동작을 수행하도록 한 클래스이다. 즉, HTTP 프로토콜 기반으로 브라우저로부터 요청을 전달받아서 처리하도록 하는 클래스이다.service() 메소드에는 요청방식에 따라 doGet(), doPost() 등 정해진 사양의 메소드가 호출되도록 구현되어 있다.

### 2.2.4. 서블릿 실행 순서

Java SE 프로그램은 개발자가 main() 메소드 안에 구현한 순서대로 실행된다. 즉, 프로그램이 실행되는 순서를 개발자가 제어한다. 그러나 `자바 EE 기반 프로그램은 실행의 흐름을 개발자가 제어하는 것이 아니라 컨테이너가 제어`한다.

이처럼 개발자가 아닌 제3자가 프로그램의 실행 흐름을 제어하는 것을 IoC(Inversion of Control)이라 한다.

<div align="center">
<img src="https://user-images.githubusercontent.com/97272787/229405788-9c0eb3eb-b643-483e-a2c5-96cc01798ae9.png">
</div>

1. 클라이언트로부터 처리 요청받음

클라이언트가 웹 브라우저를 통해 요청을 보내면 웹서버는 이를 받아서 요청정보의 헤더 안에 있는 URI를 분석한다. 이때, 요청받은 페이지가 서블릿이면 서블릿 컨테이너에 처리를 넘긴다. 서블릿 컨테이너는 요청받은 서블릿을 WEB-INF/classes나 WEB-INF/lib에서 찾아서 실행 준비를 한다.

2. 최초의 요청 여부 판단

서블릿 컨테이너는 현재 실행할 서블릿이 최초의 요청인지를 판단한다. 실행할 서블릿 객체가 메모리에 없으면 최초의 요청이고, 이미 있으면 최초의 요청이 아닌 것으로 판단한다.

3. 서블릿 객체 생성

서블릿 컨테이너는 요청받은 서블릿이 최초의 요청이라면 해당 서블릿을 메모리에 로딩하고 객체를 생성한다. 서블은 최초 요청이 들어왔을 때 한 번만 객체를 생성하고 이때 생성된 객체를 계속 사용한다.

4. init() 메소드 실행

init() 메소드는 처음 요청 시 서블릿 객체가 생성된 다음 호출되므로 주로 서블릿 객체의 초기화 작업이 구현되어 있다.

5. service() 메소드 실행

서블릿의 요청 순서에 상관없이 클라이언트의 요청이 있을 떄마다 실행된다.

service() 메소드가 끝나면 서버에서의 실행은 끝난다. 서버 프로그램 실행이 완료된 후에는 서블릿 컨테이너가 실행결과를 웹서버에 전달하고, 웹서버는 서비스를 요청한 클라이언트에 응답한다.

### 2.2.5. 콜백 메소드와 서블릿 객체의 생명주기

`콜백 메소드(callback method)`란 어떤 객체에서 어떤 상황이 발생하면 컨테이너가 자동으로 호출하여 실행되는 메소드. 이러한 콜백 메소드들이 서블릿을 실행한다.

|메소드 이름|메소드가 실행되는 시점|실행 횟수|가능 구현|
|--|--|--|--|
|init()|클라이언트로부터 최초로 서블릿 요청이 있을 때 실행|1|초기화 작업|
|service()|클라이이언트로부터 요청이 있을 때마다 실행|n|실제 서블릿이 처리해야 하는 작업|
|destroy()|서블릿 객체가 메모리에서 삭제될 때 실행(서비스나 서버 중지 시)|1|자원 해체 작업|

#### 서블릿 객체의 생성

서버 입장에서 최초로 서블릿 요청이 잇을 때, 서블릿 컨테이너는 해당 서블릿 객체를 메모리에 생성한 다음, init(), service() 순으로 실행한다. 이후에 실행 요청이 있으면 최초 요청 시 생성한 서블릿 객체의 service() 메소드를 실행한다.
한 번 생성한 서블릿 객체를 사용한다는 점에서 처리속도, 메모리 부분에서 이전의 기술보다 효율적인 장점이 있다.

#### 서블릿 객체의 삭제

최초 요청 시 생성된 서블릿 객체가 삭제되는 시점은 서버를 중지시켜 웹 애플리케이션 서비스를 중지할 때이다. 웹서버에서는 전체 서비스를 중지할 수도 있고 일부 서비스만 중지할 수도 있다. 어떤 상황이든지 `서블릿 객체가 삭제되는 시점은 웹서버에서 웹 애플리케이션 서비스가 중지되는 시점`이다.
이때 destroy() 메소드가 호출되어 실행된다.

### 2.3.1. `web.xml` 설정을 통해 접근

```xml

<servlet>
  <servlet-name> </servlet-name>
  <servlet-class> </servlet-class>
</servlet>

<servlet-mapping>
  <servlet-name> </servlet-name>
  <url-pattern> </url-pattern>
</servlet-mapping>


```

### 2.3.2. `@WebServlet`을 통해 접근

자바에서 애너테이션은 자바 실행문은 아니고 주석문처럼 컴파일러에 정보를 알려주는 기능, 또는 자바프로그램 실행에 관한 내용을 설정하는 용도로 사용된다.
`@WebServlet` 을 통해 접근해서 웹 애플리케이션 이름으로 이동하게 할 수 있음.

### 2.3.3. 요청방식에 따른 실행

서블릿이 실행될 때 service() 메소드가 자동으로 실행된다. 그래서 HttpSrvlet 클래스에 구현된 service() 메소드를 재정의하여 메소드의 몸체를 구현해야 한다. 서블릿 요청이 있을 떄마다 호출되는 메소드이므로 반드시 재정의 해야 한다.

그런데 service() 메소드를 재정의 하지 않고싶다면 어떻게 할까?

1. `protected void service(HttpServletRequest req, HttpServletResponse resp)`
2. `public void service(ServletRequest req, ServletResponse resp)`

이 중 서블릿 요청이 있을 때마다 실행되는 메소드는 2번 형태의 service() 이다. 그런데 2번 형태의 service()는 단순히 같은 객체에 있는 1번 형태의 service()를 호출해 준다. 1번 형태의 service() 메소드는 클라이언트의 실행요청에 따라 서로 다른 메소드를 호출하도록 구현되었다.

<div align="center">
  <img src="https://user-images.githubusercontent.com/97272787/229522774-6d428035-6ea4-430d-9409-b417c037a25b.png">
</div>

- 만약 똑같은 URI 요청을 요청방식에 따라 서로 다르게 동작하게 하려면 service() 메소드를 재정의하지 말고  HttpServlet 클래스의 service() 메소드가 실행되도록 한 다음, doGet() 또는 doPost() 메소드 등이 실행되도록 이 메소들을 재정의하여 구현한다.
- service() 메소드를 재정의할 것인지, 아니면 doGet(), doPost() 메소드를 재정의할 것인지는 개발 하는 상황에 맞게 적절하게 선택하면 된다.
- 이것을 반드시 구분해야 하는 경우가 있다. 한 번 제출한 상태에서 웹 브라우저 화면에서 새로고침 버튼을 누르면 두 번 제출되는 사례가 있다. 이러한 예가 발생하지 않게 하려면 서버에 제출할 때 POST 방식으로 요청하고, doPost() 메소드에 서비스 처리를 구현하면 된다.