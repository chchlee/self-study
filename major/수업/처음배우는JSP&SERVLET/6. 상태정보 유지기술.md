# 6. 상태정보 유지 기술

HTTP는 비연결형과 무상태로 동작하는 프로토콜이라 이전 연결 때의 상태정보를 서버가 유지해주지 않는다. 그러므로 상태정보를 일정 시간 동안 지속해서 유지해주는 기술이 필요한데, 이러한 기술을 `상태 정보 유지 기술`이라 하며 클라이언트에서 이를 이용하는 기술 `쿠키`와 `세션`이 있다.

### 6.1.1. 저장 위치 분류

#### 저장 기술

- 웹 애플리케이션 단위 유지
`javax.servlet.ServletContext`

- 클라이언트 단위 유지
`javax.servlet.http.HttpSession`
`javax.servlet.http.Cookie`

- 요청 단위 유지
`javax.servlet.http.HttpServletRequest`

## 6.2 ServletContext

`생명주기` - 웹 애플리케이션이 서비스 되고 있는 동안

웹 애플리케이션 단위로 정보를 서버 쪽에 유지할 수 있는 방법은 `ServletContext` 객체를 사용하는 것이다. 웹 애플리케이션 단위로 서비스하는 웹서버에서 서블릿 컨테이너는 웹 애플리케이션 단위로 `Context`를 생성하여 관리한다.

### 6.2.1. ServletContext 생성

`Servlet`는 서블릿 컨테이너와 통신하기 위해서 사용되는 메소드를 지원하는 인터페이스이다. 서블릿 컨테이너가 시작될 때 웹서버에 등록된 웹 애플리케이션 단위로 하나의 `ServletContext` 객체가 자동으로 생성된다. 그리고 웹 애플리케이션 서비스가 중지될 때 소멸한다.

<div align="center">
<img src="https://user-images.githubusercontent.com/97272787/229710510-2c450c14-da16-43f2-bbd3-d13c83b6f3ca.png">
</div>

WAS에 등록된 웹 애플리케이션 단위로 컨텍스트가 생성되는 이유는 서블릿 컨테이너가 웹 애플리케이션 단위로 모든 자원을 관리할 수 있게 하기 위해서 이다. 즉, 웹 애플리케이션 내에 있는 모든 서블릿과 JSP 간에 정보를 공유할 수 있고, 서블릿 컨테이너에 대한 정보를 추출할 수 있게 하는 기술이 바로 ServletContext이다.

```java
package com.nhnacademy.nosubject;

import javax.servlet.*;
import javax.servlet.http.*;
import javax.servlet.annotation.*;
import java.io.IOException;
import java.io.PrintWriter;

@WebServlet(name = "ServletContextTest1Servlet", value = "/context1")
public class ServletContextTest1Servlet extends HttpServlet {
    ServletContext sc; // 웹 애플리케이션 단위로 상태 정보를 유지할 수 있는 ServletContext

    @Override
    public void init(ServletConfig config) throws ServletException {
        sc = config.getServletContext();
        // getServletContext() 메소드를 사용하여 ServletConetxt의 주솟값을 저장한다.
    }

    @Override
    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        response.setContentType("text/html;charset=UTF-8");

        try(PrintWriter out = response.getWriter()){
            out.println("Context: "+ sc); // ServletContext의 주솟값을 출력한다.
            ServletContext sc1 = this.getServletContext();
            // this 키워드를 통해서도 출력할 수 있다.
            out.println("Context1: " + sc1);
        }
    }

}

```

### 6.2.2. ServletContxt 변수

#### Servlet 변숫 설정

서버가 시작될 때 생성되는 Servlet 객체는 웹 애플리케이션 단위로 생성되며, 동일한 웹 애플리케이션에 있는 모든 페이지는 동일한 `ServletContext`객체를 사용한다. 그래서 ServletContext 객체가 가지고 있는 변수는 전역변수이다.
웹 애플리케이션 단위로 사용할 수 있는 변수를 선언하고 활용하려면 web.xml에 변수를 선언한 다음, 서블릿에서 ServletContext 객체로 추출해서 사용한다.

```xml
    <!--web.xml-->
    <context-param>
    <!-- ServletContext 객체에 변수를 설정하고자 할 때 사용하는 태그 -->
        <param-name>contextConfig</param-name>
    <!--변수의 이름을 설정한다.-->
        <param-value>/WEB-INF/context.xml</param-value>
    <!--변수의 값을 설정한다.-->
    </context-param>
```

#### ServletContext 변수 추출

```java
    @Override
    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        response.setContentType("text/html;charset=UTF-8");

        try(PrintWriter out = response.getWriter()){
            out.println("Context: "+ sc);
            ServletContext sc1 = this.getServletContext(); // this 키워드를 통해서도 출력할 수 있다.
            out.println("Context1: " + sc1);

            String location = sc.getInitParameter("contextConfig");
            // getInitParameter 메소드를 활용한다.
            out.println("location: "+location);

        }
    }
```

#### 실제 개발시 `<context-param>`의 용도

실제로 프로그래밍을 할 때 기능별로 파일을 분리하는데, 이를 위한 각각의 환경설정에 대한 정보를 변수로 전달한다.

```xml
<context-param>
  <param-name>contextConfigLocation</param-name>
  <param-value>
    /WEB-INF/front.xml
    /WEB-INF/back.xml
  </param-value>
</context-param>
```

### 6.2.4. 웹 애플리케이션 단위 정보 공유

ServletContext 객체는 웹 애플리케이션 단위로 사용되는 객체이다. 즉, 동일한 웹 애플리케이션 안에 있는 모든 페이지에서 동일한 ServletContext 객체를 사용한다. 그래서 ServletContext 객체를 이용하여 웹 애플리케이션 단위로 정보를 유지함으로써 공유할 수 있다.

<div align="center">
<img src="https://user-images.githubusercontent.com/97272787/229722695-c7e23dfa-f649-4e2f-8ec5-dca47c77f384.png">
</div>

그림에서처럼 여러 페이지에서 사용할 데이터를 하나의 ServletContext 객체에 등록하면 같은 웹 애플리케이션에 소속된 다른 페이지에서 ServletConetxt 객체에 접근하여 공유된 데이터를 추출 후 사용할 수 있다.

#### void setAttribute(String name, Object value)

웹 애플리케이션 범위에서 공유할 데이터를 ServletContext 객체에 등록하는 메소드.

#### Object getAttribute(String name)

ServletContext 객체에 등록한 데이터를 추출하는 메소드

```java
@WebServlet("/context3")
public class ServletContextTest3Servlet extends HttpServlet {

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        try(PrintWriter out = resp.getWriter()){
            ServletContext sc = this.getServletContext();
            ShareObject obj1 = new ShareObject();

            obj1.setCount(1);
            obj1.setStr("test 1");
            sc.setAttribute("data1",obj1);

            ShareObject obj2 = new ShareObject();
            obj2.setCount(200);
            obj2.setStr("test2");
            sc.setAttribute("data2", obj2);
        }
    }
}

```

<div align="center">
<img src="https://user-images.githubusercontent.com/97272787/229784702-86acbf12-9a75-4a78-ab91-9e49790412c3.png">
</div>

```java
@WebServlet("/context4")
public class ServletContextTest4Servlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        resp.setContentType("text/html; charset=UTF-8");
        try(PrintWriter out = resp.getWriter()){
            ServletContext sc = this.getServletContext();

            ShareObject obj1 = (ShareObject) sc.getAttribute("data1");
            //ShareObject의 리턴값은 Object이기 때문에 형변환 해줘야한다.
            ShareObject obj2 = (ShareObject) sc.getAttribute("data2");

            out.println("DATA1 : "+obj1.getCount() + "DATA2" + obj1.getStr());
            out.println("DATA1 : "+obj2.getCount() + "DATA2" + obj1.getStr());
        }
    }
}

```

### 6.3. 쿠키

<div align="center">
<img src="https://user-images.githubusercontent.com/97272787/229667810-90646530-5358-4d7d-970d-aa397f95ca9b.png">
</div>

### 6.3.1. 쿠키 속성

쿠키는 name과 value로 구성된 정보로서 사용 목적에 따라 적절한 name과 value를 지정하고, 필요에 따라서 쿠키의 유지 시간, 유효 디렉터리, 유효 도메인 등의 속성을 함께 지정할 수 있다.

### 6.3.2. 쿠키 생성

서블릿에서는 쿠키를 설정하고 전송하며 전송된 쿠키를 추출하는 기능을 API에서 지원하고 있다.

#### 쿠키 생성 `Cooke(String name, String value)`

#### 쿠키 유효 시간 설정 `setMaxAge(int expiry)`

int expiry는 Cookie의 유효 시간의 초를 의미한다. 정숫값을 0으로 지정하면 쿠키 삭제를 의미한다. 그리고 음수값을 지정하면 쿠키가 클라이언트로 전송된 후 브라우저가 종ㄹ되면 자동으로 삭제된다.

#### 쿠키 경로 설정 `setPath(String uri)`

현재 접속중인 서버에서 이전에 클라이언트에게 전송한 쿠키가 있으면 기본적으로 요청정보 헤더 안에 쿠키가 포함되어 서버 쪽으로 전송된다. 서버의 모든 요청에 대하여 쿠키가 서버 쪽으로 전송되는 것이 아니라, 특정 경로의 요청에만 쿠키를 전송하고자 할 때 setPath() 메소드를 사용하여 경로를 지정할 수 있다.

#### 쿠키 도메인 설정 `setDomain(String domain)`

쿠키는 기본적으로 전송된 서버에서만 읽어드려 사용할 수 있다. 그런데 어떤 웹 섭시ㅡ는 하나의 서버에서만 전체 서비스를 하는 것이 아니라, 여러 대의 서버가 연결되어 서비스를 처리한다.

#### 쿠키 전송 `addCookie(Cookie cookie)`

생성된 쿠키를 클라이언트로 보낼 때는 `addCookie` 메소드를 이용한다.

### 6.3.3. 쿠키 추출

#### 쿠키 추출 `Cooke[] getCookies()`

클라이언트로 전송된 쿠키를 서버 쪽에서 읽어 드리려면 `HttpServletRequest` 객체의 `getCookie()` 메소드를 이용합니다.

#### 쿠키 검색 `String getName()`

HttpServletRequset 객체의 getCookies() 메소드는 서버가 전송한 쿠키를 한꺼번에 읽어 들여 반환하므로 반환된 쿠키 중에서 원하는 쿠키를 찾는 작업을 해야 한다.

#### 쿠키 값 추출 `String getValue()`

읽어 들인 쿠키 중에서 원하는 쿠키를 이름으로 검색해서 찾은 다음에는 쿠키의 값을 추출하여 사용 해야 한다.

```java
@WebServlet("cookie2")
public class CookieTest2Servlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        resp.setContentType("text/html; charset=UTF-8");

        try (PrintWriter out = resp.getWriter()) {
            Cookie[] list = req.getCookies();

            for (int i = 0; list != null && i < list.length; i++) {
                out.println(list[i].getName() + ":" + list[i].getValue() + "<br>");
            }
        }
    }
}
```

결괄는 이렇게 나온다.

<div align="center">
<img src="https://user-images.githubusercontent.com/97272787/229800952-44b63492-9ce6-4ef8-9433-2718e8aeda60.png">
</div>