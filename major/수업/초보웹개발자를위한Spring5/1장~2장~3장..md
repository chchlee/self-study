## 스프링이란

- 의존 주입(DI) 지원
- AOP 지원
- MVC 프레임워크 제공
- JDBC, JPA 연동, 선언적 트랜잭션 처리 등 DB 지원 연동

이 외에도 스케줄링, 메시지 연동(JMS, 정명석아님 ㅎ), 이메일 발송, 테스트 지원 등 자바 기반의 어플리케이션을 개발하는데 필요한 다양한 기능을 제공한다.

스프링 프레임워크를 이용해서 웹 애플리케이션을 개발할 때는 스프링 프레임워크만 이용하는게 아니라 여러 스프링 관련 프로젝트를 함께 사용한다.

- 스프링 데이터 : 적은 양의 코드로 데이터 연동을 처리할 수 있도록 도와주는 프레임워크.
- 스프링 시큐리티 : 인증/인가와 관련된 프레임워크.
- 스프링 배치 : 로깅/추적, 작업 통계, 실패 처리 등 배치 처리에 필요한 기본 기능을 제공한다.

## 스프링은 객체 컨테이너

스프링의 핵심 `객체를 생성하고 초기화`, 이와 관련딘 기능은 ApplcationContext라는 인터페이스에 정의되어 있다.

<div align="center">
  <img src="https://user-images.githubusercontent.com/97272787/232374505-45d469f6-1cb2-4264-a981-2c8da675b021.png">
</div>

`AnnotationConfigApplicationContext` 클래스는 애너테이션을 이용한 자바 클래스에서 정보를 읽어와 객체 생성과 초기화를 수행
`BeanFactory` 인터페이스는 객체 생성과 검색에 대한 기능을 정의. 객체를 검색하는 것 이외에 싱글톤/프로토타입 빈인지 확인하는 기능도 제공
`ApplicationContext` 인터페이스는 메시지, 프로필/환경 변수 등을 처리할 수 있는 기능을 추가로 정의한다.

Application 또는 BeanFactory는 빈 객체의 생성, 초기화, 보관, 제거 등을 관리하고 있어서 ApplcationContext를 컨테이너라고 부른다.

<div align="center">
  <img src="https://user-images.githubusercontent.com/97272787/232374859-ad5b0e44-a7d7-414f-87ce-6c509f067fac.png">
</div>

## DI와 의존 객체 변경의 유연함

의존 객체를 직접 생성하는 방식은 필드나 생성자에서 new 연산자를 이용해서 객체를 생성한다.

```java
public class MemberRegisterService {
  private MemberDao memberDao = new MemberDao();
  ...
}
```

회원의 암호 변경 기능을 제공하는 ChangeMemberService 클래스도 다음과 같이 의존 객체를 직접 생성한다고 하자.

```java
public class ChangeMemberService {
  private MemberDao memberDao = new MemberDao();
  ...
}
```

그런데 회원 데이터의 빠른 조회를 위해 캐시를 적용해야 하는 상황이 발생했다.

```java
public class CachedMemberDao extends MemberDao { {
  ...
}
```

캐시 기능을 적용한 ChachedMemberDao를 사용하려면 MemberRegisterService 클래스와 ChangePasswordService 클래스의 코드를 2번 변경해줘야 한다. 만약 객체가 3,4,5개라면.. 그에 맞게 변경해줘야 한다.

동일한 상황에서 DI를 사용하면 수정할 코드가 줄어즌다.

```java
public class ChangeMemberService {
  private MemberDao memberDao;
  public MemberRegisterService(MemberDao memberDao){
    this.memberDao = memberDao;
  }
  ...
}


public class MemberRegisterService {
  private MemberDao memberDao;
  public MemberRegisterService(MemberDao memberDao){
    this.memberDao = memberDao;
  }
  ...
}
```

두 클래스의 객체를 생성하는 코드는 다음과 같다.

```java
MemberDao memberDao = new MemberDao();
MemberRegisterService regSvc = new MemberRegisterService(memberDao);
ChangePasswordService pwdSvc = new ChangePasswordService(memberDao);
```

생성자를 통해 DI를 했다면 변경하려면 객체를 생성하는 부분만 변경하면 된다.

```java
MemberDao memberDao = new CachedMemberDao();
MemberRegisterService regSvc = new MemberRegisterService(memberDao);
ChangePasswordService pwdSvc = new ChangePasswordService(memberDao);
```

이렇게 객체 생성시 DI를 사용하면 더욱 유연한 코드를 작성할 수 있다.

### 생성자 방식 DI vs 세터 메서드 DI

- 생성자 방식 : 빈 객체를 생성하는 시점에서 모든 의존 객체 주입. 파라미터가 많으면 각 인자가 어떤 의존 객체를 설정하는지 알아내려면 생성자 코드를 알아내야 한다. 그러나 빈 객체를 생성하는 시점에 모든 의존 객체를 주입받기 때문에 객체를 완전히 사용할 수 있다는 장점이 있다.
- 세터 방식 : 세터 메서드 이름을 통해 어떤 의존 객체가 주입되는지 알 수 있다. 세터 방식은 어떤 인자가 의존 객체를 설정하는지 쉽게 유추 가능하다. 필요한 의존 객체를 전달하지 않아도 빈 객체가 생성되어 NPE 가 발생할 수 있다.

`@Autowired` : Autowired 애너테이션을 의존 주입 대상에 붙이면 스프링 설정 클래스의 @Bean 메서드에서 의존 주입을 위한 코드를 작성하지 않아도 된다.

```java
@Configuration
public class AppConfg2 {
  @Autowired
  private MemberDao memberDao();
  @Autowired
  private MemberPrinter memberPrinter;
}
```

스프링은 `@Configuration` 애너테이션이 붙은 설정 클래스를 내부적으로 스프링 빈으로 등록한다. 그리고 다른 빈과 마찬가지로 `@Autowired`가 붙은 대상에 대해 알맞은 빈을 자동으로 주입한다.

### @Import 애너테이션 사용

두 개 이상의 설정 파일을 사용하는 또 다른 방법은 @Import 애너테이션을 사용하는 것이다.

```java
@Configuration
@Import(AppConfg2.class)
public class AppConfImport {

  @Bean
  public MemberDao memberDao() {
    return new MemberDao();
  }

  @Bean
  public MemberPrinter memberPrinter() {
    return new MemberPrinter();
  }
}
```

혹은

```java
@Configuration
@Import({AppConf1.class, AppConf2.class})
public class AppConImport {

}
```

이런 방법도 있다.

## 주입 대상 객체를 모두 빈 객체로 설정해야 하나?

주입할 객체가 꼭 스프링 빈이어야 할 필요는 없다. 예를 들어 MemberPrinter를 빈으로 등록하지 않고 일반 객체로 생성해서 주입할 수 있다.

```java
@Configuration
public class AppCtxNoMemberPrinterBean {
  private MemberPrinter printer = new MemberPrinter();
  ...

  @Bean
  public MemberListPrinter listPrinter() {
    return new MemberListPrinter(memberDao(), printer);
  }

  @Bean
  public MemberInfoPrinter infoPrinter() {
    MemberInfoPrinter infoPrinter = new MemberInfoPrinter();
    infoPrinter.setMemberDao(memberDao());
    infoPrinter.setPrinter(printer);
    return infoPrinter;
  }
  ...
}
```

객체를 스프링 빈으로 등록할 때와 등록하지 않았을 때의 차이는 스프링 컨테이너가 객체를 관리하는지 여부이다.

### @Autowired

@Autowired 애너테이션을 필드나 세터 메서드에 붙이면 스프링은 타입이 일치하는 빈 객체를 찾아서 주입한다.

### @Qualifier 애너테이션을 이용한 의존 객체 선택

자동 주입 가능한 빈이 두 개 이상이면 자동 주입할 빈을 지정할 수 있는 방법이 필요하다. 이 떄 Qualifier 애너테이션을 사용한다.

### @Component 애너테이션으로 스캔 대상 지정

스프링이 검색해서 빈으로 등록할 수 있으려면 클래스에 @Component 애너테이션을 붙여야 한다.
`@Component`애너테이션은 해당 클래스를 스캔 대상으로 표시한다.

### ComponentScan 애너테이션으로 스캔 설정

스캔 대상 설정가능

### 스캔 대상에서 제외하거나 포함하기

excludeFilters 속성을 사용하면 스캔할 때 특정 대상을 자동 등록 대상에서 제외할 수 있다.

```java
@Configuration
@ComponentScan(basePackage = {"spring"},
  excludeFilters = @Filter(type = FilterType.REGEX, pattern = "spring\\..*Dao"))
public class AppCtxWithExclude {
  @Bean
  public MemberDao memberDao() {
    return new MemberDao();
  }
  ...
}
```

FilterType.REGEX는 정규표현식을 사용해서 제외 대상을 지정한다는 것을 의미
pattern 속성은 FilterType에 적용할 값을 설정. spring으로 시작하고 Dao로 끝나는 정규 표현식을 지정한다.

FilterType.ASPECTJ를 필터 타입으로 지정할 수도 있다.

설정하면 거른다.


### 기본 스캔 대상

@Component 애너테이션을 붙인 클래스만 컴포넌트 스캔 대상에 포함되는 게 아니다.

- @Component
- @Controller
- @Service
- @Repository
- @Aspect
- @Configuration

## 빈 객체의 라이프사이클

<div align="center">
  <img src="https://user-images.githubusercontent.com/97272787/232434300-63baae24-5bd8-4db5-bd58-c635c02e143b.png">
</div>

스프링 컨테이너를 초기화할 때 스프링 컨테이너는 가장 먼저 빈 객체를 생성하고 의존을 설정한다. 의존 자동 주입을 통한 의존 설정이 이 시점에 수행된다. 모든 의존 설정이 완료되면 빈 객체의 초기화를 수행한다. 빈 객체를 초기화하기 위해 스프링은 빈 객체의 지정된 메서드를 호출한다.

### 빈 객체의 초기화와 소멸 : 스프링 인터페이스

- org.springframework.beans.factory.InitializingBean
- org.springframework.beans.factory.DisposableBean

```java
public interface InitializingBean {
  void afterPropertiesSet() throws Exception;
}

public interface DisposableBean {
  void destroy() throws Exception;
}
```

빈 객체가 InitializingBean 인터페이스를 구현하면 스프링 컨테이너는 초기화 과정에서 빈 객체의 afterPropertiesSet() 메서드를 실행한다. 빈 객체를 생성한 뒤에 초기화 과정이 필요하면 InitializingBean 인터페이스를 상속하고 afterPropertiesSet() 메서드를 알맞게 구현하면 된다.

스프링 컨테이너는 빈 객체가 DisposableBean 인터페이스를 구현한 경우 소멸 과정에서 빈 객체의 destory() 메서드를 실행한다. 빈 객체의 소멸 과정이 필요하면 DisposableBean 인터페이스를 상속하고 destory() 메서드를 알맞게 구현하면 된다.

초기화와 소멸 과정이 필요한 예가 데이터베이스 커넥션 풀이다.
또 다른 예로 채팅 클라이언트가 있다.


## 커스텀 메서드

initMethod와 destoryMethod를 지정해주면 된다.

## AOP 프로그래밍

aspectjweaver 모듈은 aop를 설정하는데 필요한 애노테이션을 제공한다.

## AOP

여러 객체에 공통으로 적용될 수 있는 기능을 분리해서 재사용성을 높여주는 프로그래밍 기법이다. AOP는 핵심 기능과 공통 기능의 구현을 분리함으로써 핵심 기능을 구현한 코드의 수정 없이 공통 기능을 적용할 수 있게 만들어 준다.

AOP의 기본 개념은 핵심 기능에 공통 기능을 삽입하는 것이다. 핵심 기능의 코드를 수정하지 않으면서 공통 기능의 구현을 추가하는 것이 AOP이다.

- 컴파일 시점에서 코드에 공통 기능을 삽입하는 방법
- 클래스 로딩 시점에 바이트 코드에 공통 기능을 삽입하는 방법
- 런타임에 프록시 객체를 생성해서 공통 기능을 삽입하는 방법

|용어|의미|
|--|--|
|Advice|언제 공통 관심 기능을 핵심 로직에 적용할 지를 정의하고 있다. 예를 들어 '메서드를 호출하기 전'에 트랜잭션 시작 기능을 적용한다는 것을 정의한다.|
|JoinPoint|Advice를 적용 가능한 지점을 의미한다. 메서드 호출, 필드 값 변경 등이 Joinpoint에 해당한다. 스프링은 프록시를 이용해서 AOP를 구현하기 때문에 메서드 호출에 대한 JoinPoint만 지원한다.|
|Pointcut|Joinpoint의 부분 집합으로서 실제 Advice가 적용되는 Joinpoint를 나타낸다. 스프링에서는 정규 표현식이나 AspectJ의 문법을 이용하여 Pointcut을 정의할 수 있다.|
|Weaving|Advice의 핵심 로직 코드에 적용하는 것을 weaving이라 한다.|
|Aspect|여러 객체에 공통으로 적용되는 기능을 Aspect라 한다. 트랙재션이나 보안 등이 좋은 예이다.|


스프링에서 구현 가능한 Advice의 종류

|종류|설명|
|--|--|
|Before Advice|대상 객체의 메서드 호출 전에 공통 기능을 설명한다.|
|After Returning Advice|대상 객체의 메서드가 익셉션 없이 실행된 이후에 공통 기능을 실행한다.|
|After Throwing Advice|대상 객체의 메서드를 실행하는 도중 익셉션이 발생한 경우에 공통 기능을 수행한다.|
|After Advice|익셉션 발생 여부에 상관없이 대사 객체의 메서드 실행 후 공통 기능을 실행한다.|
|Around Advice|대상 객체의 메서드 실행 전, 후 또는 익셉션 발생 시점에 공통 기능을 실행하는데 사용된다.|

`@EnableAspectJAutoProxy` 이 애너테이션을 추가하면 @Aspect 애너테이션이 붙은 빈 객체를 찾아서 빈 객체의 Pointcut 설정과 Around 설정을 사용한다.

<div align="center">
<img src="https://user-images.githubusercontent.com/97272787/232507098-9188f068-92d7-4e62-bd69-7c434bd6d878.png">
</div>