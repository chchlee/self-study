## 메이븐 의존 설정

```xml
<dependency>
  <groupId>org.springframework</groupId>
  <artifactId>spring-context</artifactId>
  <version>5.0.2.RELEASE</version>
</dependency>
```

- 메이븐은 한 개의 모듈을 아티팩트라는 단위로 관리한다.
- 위 설정은 `spring-context` 라는 식별자를 가진 5.0.2.RELEASE 버전의 아티팩트에 대한 의존을 추가한 것이다.

메이븐은 코드를 컴파일하거나 실행할 때 `<dependency>`로 설정한 아티팩트 파일을 사용한다.

- 메이븐 로컬 리포지토리에서 `[그룹ID]\[아티팩트ID]\[버전] 폴더에 아티팩트ID-버전.jar` 형식의 이름을 갖는 파일이 있는지 검사한다. 파일이 존재하면 이 파일을 사용한다.
- 로컬 리포지토리에 파일이 없으면 메이븐 원격 중앙 리포지토리로부터 해당 파일을 다운로드하여 로컬 리포지토리에 복사한 뒤 그 파일을 사용한다.

#### 메이븐 원격 중앙 리포지토리?

메이븐 아파치 재단에서 메이븐 중앙 리포지토리에 아티팩트 파일을 등록하는 방법을 제공한다.

#### 의존 전이(Transitive Dependencies)

<div align="center">
  <img src="https://user-images.githubusercontent.com/97272787/230876587-60e6f9d0-aefd-4310-b5bb-611d5240b327.png">
</div>

- 의존한 아티팩트가 또 다시 의존하는 아티팩트가 있기 때문에 그 아티팩트도 다운로드 된다.
- 이렇게 의존 대상이 다시 의존하는 대상까지도 의존 대상에 포함되기 때문에 이를 의존 전이(Transitive Dependencies)라 한다.

## 스프링은 객체 컨테이너 ?

스프링의 핵심은 `객체를 생성하고 초기화` 하는 것. `AnnotationConfigApplicationContext` 클래스는 자바 클래스에서 정보를 읽어와 객체 생성과 초기화를 수행한다.

<div align="center">
  <img src="https://user-images.githubusercontent.com/97272787/230883051-0b783d48-ef5a-4126-9436-ac5a6457e128.png">
</div>

- BeanFactory : 객체 생성과 검색에 대한 기능을 정의. 싱글톤/프로토타입 빈인지 확인도 할 수 있음.
- ApplicationContext : 메시지, 프로필/환경 변수 등을 처리할 수 있는 기능도 있음.
- AnnotationConfigApplicationContext : 자바 애너테이션을 이용한 클래스로부터 객체 설정 정보를 가져옴.
- GenericXmlApplicationContext : XML로부터 객체 설정 정보를 가져옴.
- GenericGroovyApplicationContext : 그루비 코드를 이용해 설정 정보를 가져옴.

어떤 구현 클래스를 사용하든, 각 구현 클래스는 설정 정보로부터 빈(Bean)이라 불리는 객체를 생성하고 그 객체를 내부에 보관한다. 그리고 getBean() 메서드를 실행하면 해당하는 빈 객체를 제공한다.

```java
// 1. 설정 정보를 이용해서 빈 객체를 생성한다.
AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(AppContext.class);

// 2. 빈 객체를 제공한다.
Greeter g = ctx.getBean("greeter", Greeter.class);
```

ApplicationContext(또는 BeanFactory) 는 빈 객체의 생성, 초기화, 보관, 제거 등을 관리하고 있어서 ApplicationContext를 컨테이너 라고도 부른다.

### 의존이란?

한 클래스가 다른 클래스의 메서드를 실행할 때 이를 `의존`한다고 표현한다.
클래스 내부에서 직접 의존 객체를 생성하는 것이 쉽긴 하지만 유지보수 관점에서 문제점을 유발할 수 있다.

### DI를 통한 의존 처리

DI(Dependency Injection) 는 의존하는 객체를 직접 생성하는 대신 의존 객체를 전달받는 방식을 사용한다.
직접 의존 객체를 생성했던 코드와 달리 의존 객체를 생성하지 않는다. 대신 생성자를 통해서 의존 객체를 전달 받는다. 즉, 생성자를 통해 의존하고 있는 객체를 주입 받은 것이다. 의존 객체를 직접 구하지 않고 생성자를 통해서 전달받기 때문에 이 DI(의존 주입) 패턴을 따르고 있다.

### DI와 의존 객체 변경의 유연함

의존 객체를 생성하는 방법은 필드나 생성자에서 new 연산자를 이용해서 객체를 생성한다. 자바의 `다형성`을 이용하자.

### 객체 조립기(assembler)?

DI를 설명할 때 객체 생성에 사용할 클래스를 변경하기 위해 객체를 주입하는 코드 한 곳만 변경하면 될 것 같다.
실제 객체를 생성하는 곳은? 메인 메서드에서 생성하면 될 것 같다.
그러나 이 방법보단 객체를 생성하고 의존 객체를 주입해주는 클래스를 따로 작성하는 것이 좋을 것 같다. 의존 객체를 주입한다는 것은 서로 다른 두 객체를 조립한다고 생각할 수 있는데, 이런 의미에서 이 클래스를 조립기라고 표현한다.

스프링은 DI를 지원하는 조립기이다. 즉 스프링은 생성자 코드처럼 필요한 객체를 생성하고 생성한 객체에 의존을 주입한다.

### DI 방식 1 : 생성자 방식

생성자를 통해 의존 객체를 주입 받는다.

### DI 방식 2 :세터 메서드 방식

생성자 외에 세터 메서드를 이용해서 객체를 주입받기도 한다.

- 메서드 이름이 set으로 시작한다.
- set 뒤에 첫 글자는 대문자로 시작한다.
- 파라미터가 1개이다.
- 리턴 타입이 void이다.

생성자 DI 방식과 세터 메서드 DI 방식?

- 생성자 방식 : 빈 객체를 생성하는 시점에 모든 의존 객체가 주입된다.
- 설정 메서드 방식 : 세터 메서드 이름을 통해 어떤 객체가 주입되는지 알 수 있다.
