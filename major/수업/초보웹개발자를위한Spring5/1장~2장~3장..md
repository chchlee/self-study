## 스프링이란

- 의존 주입(DI) 지원
- AOP 지원
- MVC 프레임워크 제공
- JDBC, JPA 연동, 선언적 트랜잭션 처리 등 DB 지원 연동

이 외에도 스케줄링, 메시지 연동(JMS, 정명석아님 ㅎ), 이메일 발송, 테스트 지원 등 자바 기반의 어플리케이션을 개발하는데 필요한 다양한 기능을 제공한다.

스프링 프레임워크를 이용해서 웹 애플리케이션을 개발할 때는 스프링 프레임워크만 이용하는게 아니라 여러 스프링 관련 프로젝트를 함께 사용한다.

- 스프링 데이터 : 적은 양의 코드로 데이터 연동을 처리할 수 있도록 도와주는 프레임워크.
- 스프링 시큐리티 : 인증/인가와 관련된 프레임워크.
- 스프링 배치 : 로깅/추적, 작업 통계, 실패 처리 등 배치 처리에 필요한 기본 기능을 제공한다.

## 스프링은 객체 컨테이너

스프링의 핵심 `객체를 생성하고 초기화`, 이와 관련딘 기능은 ApplcationContext라는 인터페이스에 정의되어 있다.

<div align="center">
  <img src="https://user-images.githubusercontent.com/97272787/232374505-45d469f6-1cb2-4264-a981-2c8da675b021.png">
</div>

`AnnotationConfigApplicationContext` 클래스는 애너테이션을 이용한 자바 클래스에서 정보를 읽어와 객체 생성과 초기화를 수행
`BeanFactory` 인터페이스는 객체 생성과 검색에 대한 기능을 정의. 객체를 검색하는 것 이외에 싱글톤/프로토타입 빈인지 확인하는 기능도 제공
`ApplicationContext` 인터페이스는 메시지, 프로필/환경 변수 등을 처리할 수 있는 기능을 추가로 정의한다.

Application 또는 BeanFactory는 빈 객체의 생성, 초기화, 보관, 제거 등을 관리하고 있어서 ApplcationContext를 컨테이너라고 부른다.

<div align="center">
  <img src="https://user-images.githubusercontent.com/97272787/232374859-ad5b0e44-a7d7-414f-87ce-6c509f067fac.png">
</div>

## DI와 의존 객체 변경의 유연함

의존 객체를 직접 생성하는 방식은 필드나 생성자에서 new 연산자를 이용해서 객체를 생성한다.

```java
public class MemberRegisterService {
  private MemberDao memberDao = new MemberDao();
  ...
}
```

회원의 암호 변경 기능을 제공하는 ChangeMemberService 클래스도 다음과 같이 의존 객체를 직접 생성한다고 하자.

```java
public class ChangeMemberService {
  private MemberDao memberDao = new MemberDao();
  ...
}
```

그런데 회원 데이터의 빠른 조회를 위해 캐시를 적용해야 하는 상황이 발생했다.

```java
public class CachedMemberDao extends MemberDao { {
  ...
}
```

캐시 기능을 적용한 ChachedMemberDao를 사용하려면 MemberRegisterService 클래스와 ChangePasswordService 클래스의 코드를 2번 변경해줘야 한다. 만약 객체가 3,4,5개라면.. 그에 맞게 변경해줘야 한다.

동일한 상황에서 DI를 사용하면 수정할 코드가 줄어즌다.

```java
public class ChangeMemberService {
  private MemberDao memberDao;
  public MemberRegisterService(MemberDao memberDao){
    this.memberDao = memberDao;
  }
  ...
}


public class MemberRegisterService {
  private MemberDao memberDao;
  public MemberRegisterService(MemberDao memberDao){
    this.memberDao = memberDao;
  }
  ...
}
```

두 클래스의 객체를 생성하는 코드는 다음과 같다.

```java
MemberDao memberDao = new MemberDao();
MemberRegisterService regSvc = new MemberRegisterService(memberDao);
ChangePasswordService pwdSvc = new ChangePasswordService(memberDao);
```

생성자를 통해 DI를 했다면 변경하려면 객체를 생성하는 부분만 변경하면 된다.

```java
MemberDao memberDao = new CachedMemberDao();
MemberRegisterService regSvc = new MemberRegisterService(memberDao);
ChangePasswordService pwdSvc = new ChangePasswordService(memberDao);
```

이렇게 객체 생성시 DI를 사용하면 더욱 유연한 코드를 작성할 수 있다.

### 생성자 방식 DI vs 세터 메서드 DI

- 생성자 방식 : 빈 객체를 생성하는 시점에서 모든 의존 객체 주입. 파라미터가 많으면 각 인자가 어떤 의존 객체를 설정하는지 알아내려면 생성자 코드를 알아내야 한다. 그러나 빈 객체를 생성하는 시점에 모든 의존 객체를 주입받기 때문에 객체를 완전히 사용할 수 있다는 장점이 있다.
- 세터 방식 : 세터 메서드 이름을 통해 어떤 의존 객체가 주입되는지 알 수 있다. 세터 방식은 어떤 인자가 의존 객체를 설정하는지 쉽게 유추 가능하다. 필요한 의존 객체를 전달하지 않아도 빈 객체가 생성되어 NPE 가 발생할 수 있다.

`@Autowired` : Autowired 애너테이션을 의존 주입 대상에 붙이면 스프링 설정 클래스의 @Bean 메서드에서 의존 주입을 위한 코드를 작성하지 않아도 된다.

```java
@Configuration
public class AppConfg2 {
  @Autowired
  private MemberDao memberDao();
  @Autowired
  private MemberPrinter memberPrinter;
}
```

스프링은 `@Configuration` 애너테이션이 붙은 설정 클래스를 내부적으로 스프링 빈으로 등록한다. 그리고 다른 빈과 마찬가지로 `@Autowired`가 붙은 대상에 대해 알맞은 빈을 자동으로 주입한다.

### @Import 애너테이션 사용

두 개 이상의 설정 파일을 사용하는 또 다른 방법은 @Import 애너테이션을 사용하는 것이다.

```java
@Configuration
@Import(AppConfg2.class)
public class AppConfImport {

  @Bean
  public MemberDao memberDao() {
    return new MemberDao();
  }

  @Bean
  public MemberPrinter memberPrinter() {
    return new MemberPrinter();
  }
}
```

혹은

```java
@Configuration
@Import({AppConf1.class, AppConf2.class})
public class AppConImport {

}
```

이런 방법도 있다.

## 주입 대상 객체를 모두 빈 객체로 설정해야 하나?

주입할 객체가 꼭 스프링 빈이어야 할 필요는 없다. 예를 들어 MemberPrinter를 빈으로 등록하지 않고 일반 객체로 생성해서 주입할 수 있다.

```java
@Configuration
public class AppCtxNoMemberPrinterBean {
  private MemberPrinter printer = new MemberPrinter();
  ...

  @Bean
  public MemberListPrinter listPrinter() {
    return new MemberListPrinter(memberDao(), printer);
  }

  @Bean
  public MemberInfoPrinter infoPrinter() {
    MemberInfoPrinter infoPrinter = new MemberInfoPrinter();
    infoPrinter.setMemberDao(memberDao());
    infoPrinter.setPrinter(printer);
    return infoPrinter;
  }
  ...
}
```

객체를 스프링 빈으로 등록할 때와 등록하지 않았을 때의 차이는 스프링 컨테이너가 객체를 관리하는지 여부이다.

