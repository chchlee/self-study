여기를 왜 지원하게 됐나요?

2주전에 마음먹은거
너넨 뒤졋다.

가볍게 있을 곳이 아니다. 상황이

새벽 4시까지 잠을 못잠

내 교육관은 상향 평준화인데 그렇지 않더라
2주 전에 면접봤을 때 느낀 것은 그렇지 않았음.

너네는 찬스를 잡았다.

앞선 과정에서 잘 못따라갔다면 죽을만큼 해봐라

죽을 만큼 노력하면 된다.

새로운 것을 한다는 것은 여태까지 내가 못해도 뛰어넘을 찬스가 생긴 것이다.
숙제 제출안하는 것은 여러분들일 기회를 차는 것이다.

스프링 프레임워크

2개 이상의 컴포넌트로 이루어진 것을 엔터프라이즈 애플리케이션이라 한다.

스프링 프레임워크는 엔터프라이즈 애플리케이션을 위한 프레임워크이다.

프레임워크 vs 라이브러리

주도권의 차이

프레임워크는 내 코드를 호출(호출 당하는 것)
라이브러리는 내가 주도해서 라이브러리를 호출하는 것

- 공통점
  - 특정 문제를 일반적인 방법으로 해결하기 위한 코드를 제공
  - 재활용할 수 있다.

- 차이점
  - framework는 원하는 기능을 구현하기 위하여 일정한 형태를 제공(SRPING MVC는 URI를 파싱하는 메서드 제공)

프레임워크는 기능적 요구사항과 비 기능적 요구사항을 관리할 수 있음
기능적 요구사항 : 메일을 보낼 수 있어야한다. 로그인을 할 수 있어야한다. 사용자가 실질적으로 다룰 수 있는(사용자가 볼 수 있는)
비기능적 요구사항 : 사용자가 볼 수 없는...(RDB 트랜잭션) 사용자는 볼 수 없지만, 무조건 들어가야 하는 http 프로토콜 .. 등등

자바로 하면 대부분 스프링,.. 디팩토(de facto.. 사실상 표준)

스프링이 창궐하기 전에 과거 EJB를 썼음

1. 느림
2. 프레임워크의 제공해주는 코드의 의존이 너무 강하다.(interusive........)

스프링은 EJB에 비해서

1. lightweight(EJB에 비해서)
2. 내가 필요한 기능만 딱 떼다가 쓰기 좋음.(modular..)
3. 순수 자바로만 개발할 수 있음. (3.0 애너테이션 이후로는..?)
4. pojo라는 것으로 짤 수 있다.?

SpringFramework의 특징

1. 경량 컨테이너, Spring Bean을 직접관리
꼬리에 꼬리를 무는 Springbean.. : 스프링컨테이너에 의해 관리받는 자바 객체(일반적으로)

- 스프링 빈의 객체의 라이프 사이클을 관리한다.(라이프 사이클 ? 일반적으로 new를 사용해서 인스턴스 생성 - 호출 - 더 이상의 레퍼런스가 없을 때 GC에 의해 소멸되는)
- 자바 빈 객체의 생성, 보관, 제거에 관한 모든일을 처리

오늘 내일 모레까지 스프링 컨테이너에 관해 계속 이야기

어떻게 생성 조합 . ..

2. POJO 기반

- 일반적인 J2EE 프레임워크와 비교해서, 특정 인터페이스를 구현하고 상속받을 필요가 없다.
- 기본 라이브러리를 사용하기 편함

3. 제어 역전(IoC)

- 컨트롤의 제어권이 사용자가 아니라 프레임워크에 있다. 필요에 따라 Spring이 사용자의 코드를 호출
- IoC를 컨트롤하기위해 DI(의존성 주입)이라는 방식으로 개발되어 있다.
- 스프링 프레임워크는 DDD, TDD를 기반으로 만들어진 프레임워크이다.(DDD, TDD를 사용하기에 매우 적합하다. Service, Controller ... etc)

4.관점 지향 프로그래밍(AOP) 지원

- 프로그래밍의 패러다임 : 객체지향, 함수형 딱 2가지래요.
- 관점지향은 새로운 패러다임이 아니라, 객체 지향 프로그래밍을 다른 방법으로 풀어놓은 것..? 프로그래밍 관점에서보면 비기능적에서 연관이 있따. RDB에 관점에서 보면 트랜젹선 시작과 종료가 있어야돼. 성능측정하는 애플리케이션의 관점에서 봤을 때는 쓰레드의 시작과 종료의 시간을 구해서 얼마나 시간이 걸렸는지 궁금. 보안의 관점에서 봤을대 어떤 http call을 했을 떄 비즈니스 로직 시작전 인증 인가가 되어 있어야돼. 이런 관점들은 사용자들 입장에선 별로 중요한게 아님. 그러나 공통적으로 필요한 것들. 쿼리를 시작하기 전에 transaction begin .. 정상적으로 끝나면 commit .. 에러가 ㅅ발생했을 떄는 롤백해야함.

5. 영속성 지원

- 영원히 저장하는 ? 메모리 객체 데이터 수정. 메모리에 무언가를 적어 놓으면 애플리케이션 종료하면 메모리 날라감. 여러분들이 db에다 적거나 파일에다 적거나. 일반적으로 이런것들을 영속적으라 하는데 일반적으로 영속성이라 하는것은 db에 저장하고 읽어오는 과정을 영속성이라 한다. 생각해보면 모든 애플리케이션의 기능은 데이터 저장 수정 .. . 어떻게 하면 효율적으로 저장하고 읽고 수정하는 것에 포커스가 맞춰져있음. mybatis, hibernate(jpa 표준의 구현체), jdbc, jpa

6. 한국의 Spring Framework

전자정부 표준 프레임워크? 이걸 안쓰면 납품이안됨. 정지범 수석님이 교재를 썼다고 함. 아버지래요

월 화 수

컨셉은 한석봉과 어머니
실습이 잘안되면 집에가서라도 꼭 실습을 해라. 그러면 목 금은 자율학습시간(과제)

어떻게 하면 실습을 안놓치고 잘 따라올까?
0번 과제

이것에 대해 꼭 주고싶은 말?
어떤 코드던 쓰지 않는 코드던 주석처리 하지마라. 쓰잘데기 없는 가독성에 방해가 되는 조금이라도 가독성에 방해가 되는 코드가 있으면 받지말아라. psvm 해도 된다. 그런데 제출할때는 절 때 쓰지마
사용하지 않는 클래스 포함시켜서 제출하지 말아라. 여러분들이 취업을 할 때 라이브코딩을 하던 숙제제출을 하던. 좋같은ㅇ 코드치지마세요. 모든 그 기능을 표현할 수 있도록 잘 정의해라

클래스 메소드이름 ? `grep.app` 사이트 가보세요. 혹은 챗지피티 써도됨.
테스트 케이스는 반드시 작성하세요. TC(TESTCASE)를 작성하지 않는 애플리케이션은 유지보수 할 수 없음. 엔터프라이즈 애플리케이션에선 무조건 무조건 테스트 케이스 쓰세요.

테스트 케이스가 뭔지 모르면 JUNIT이 뭔지 공부해보세요
0번 과제는 pass와 fail임 요구사항 안지키면 넌 뒤진다.

제대로 알아라.

과제부터도 훈련이 되어 있어야 앞으로 코딩하는데도 습관화가 될 것이다.

Spring Framework Modules

코어는 다 들어가니까 무조건 알아라

1. Spring-core : 핵심유틸리티포함
2. Spring-context : bean-factory, ioc-container 등 .. Application-Context이다. 이거 없이는 스프링이 안돌아간다.
3. Spring-context-support : third-part 라이브러리를 통합된. 쿼츠 구아바 등
4. Spring-beans : Spring bean과 관련된 애너테이션
5. Spring-expression : SPEL관련 기능. value라는 애너테이션을 쓰면 이걸 쓰게 된다.

aop

spring-aop :
spring-aspects :

data/영속성..
spring jdbc : 자바에선 무조건 jdbc연관 디비관련이면
spring test : 클래스 두개 이상이라면 큰 기능 : integration test 가상의 디비나 저장소를 사용해서 .. unit test는 클래스 하나
spring tx : 트랜잭션
spring web , web-mvc : http 기술들을 다루는 친구들

스프링 프로젝트
스프링부트
스프링
스프링데이터 : jpa, redis, mongodb, etc......
스프링 배치 : 배치 프로그램? 일련의 작업들을 작업 단위로 묶어 연속적으로 일괄 처리하는 것.(은행, 하루에 얼마나 입금이 됐나. 출금이 얼마나 됏나 . 배치 프로그램으로 일괄처리). 인증? 유저를 확인하는 절차(로그인) 인가? 로그인 한 사람의 권한 등급을 확인하면서 권한을 부여하는 작업(인가) spring security.
스프링 amqp : 메시지 큐라고 하는 그 내용을 표준 프로토콜로 정의 해놓은 것이 amqp

스프링 부트 vs 스프링 코어?
스프링 부트는 기본설정만 하면 바로 개발할 수 있음. 내장 톰캣 .. 버전 관리 ..

스프링 코어는  일일이 하나하나 올려야하는
스프링 부트는 이미 만들어진 것을 부트에서 가이드하는것을 따라만 하면 동작! 굿
스프링코어 랑 부트는 달라요! 무시하면됨 . 스프링 부트는 스프링 코어를 의존하고 있음. !!

new project ...

<dependencies>
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-context</artifactId>
        <version>5.3.17</version>
    </dependency>
</dependencies>

pom.xml 추기하면 됨

버전을 맞춰야한다. 어떤 버전에선 되는데 어떤 버전으 안되고..
이런 것을해결하기 위해 `bill-of-material`, 즉 `spring-frame-bom`을 제공한다.

```xml

    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>org.springframework</groupId>
                <artifactId>spring-framework-bom</artifactId>
                <version>5.3.17</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>

    <dependencies>
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-context</artifactId>
        </dependency>
    </dependencies>

```

이렇게하면 context의 버전에 의존하지 않고 관리가 됨.

궁금하면 `spring-framework-bom` 을 들어가면 버전에 맞게 다 들어가는 것을 볼 수 있다.

스프링 트라이앵글

1. DI
2. AOP
3. PSA

pojo를 중심으로 자바 클래스를 작성하면 되고, 이 자바 클래스를 3가지가 도와줘서 스프링 프레임워크가 된다.!!

<img src="https://nhnent.dooray.com/share/tree/zbJkAsWKRWiiLFiAxI7Jtw/pages/3213939178600793259/attach-files/3213939538108164552">

di aop psa 를 기준으러 어떻게 적용하는지. 하루종일 한다

다형성이 뭐에요
추상화가 뭐에요
이런식으로 꼬리질문

어떤 클래스가 어떤 기능을 하는지 공통적을 뽑아낸 것.

manifest.md

스프링에서 IOC란 무엇이냐

프레임워크는 나의 코드를 호출, 라이브러리는 내가 호출
즉, 제어권이 프레임워크

제어권을 프레임워크가 갖는 것.(IoC)

스프링 빈은 new 키워드를 써서 객체를 생성하지 않아요
이 클래스가 스프링 빈이 될거야 라고 설정말 하자.

코드 작성도 프레임워크가 하는대로... 객체 생성도 프레임워크가..
개발자는 프레임워크가 하라는대로 해용

프레임워크는 이 설정을 보고 객체를 생성하고, 코드가 동작하는 순서를 결정하여 실행

```java
public class Main {
    public static void main(String[] args) {
        SmsMessageSender smsMessageSender = new SmsMessageSender(); // 얘부터 생성하자. 그런데, 스프링 프레임워크는 알고 있다. 이 순서를 그래서 알아서 잡아줌.
        MessageSendService messageSendService = new MessageSendService(smsMessageSender); // 스프링 프레임워크는 객체를 실행하는 순서를 결정해서 실행한다. 순환 참조되면 exception 떠버림.
        messageSendService.doSendMessage(); // 그래서 실행 못하게함.
    }
}
```

이 원칙을 헐리우드 원칙이라고도 한다.

프레임워크와 라이브러리의 차이점이 뭔가요 ?
가장 큰 차이점은 제어권입니다. 프레임워크는 제어권이 프레임워크가 가지고 있고, 라이브러리는 개발자가 제어권을 가지고 있습니다.
이와 연관된 말로는 IoC가 있다.

예시 ) 템플릿 메서드 패턴

template 으로 존재하는 method + pattern
추상 클래스에 템플릿에 해당하는 메소드에서 실행의 흐름이 이미 결정되어있음.

템플릿 메서드 패턴의 가장 큰 예시로는 `template method pattern`이 있다. 이미 추상 클래스에 템플릿에 해당하는 메소드에서 실행의 흐름이 이미 결정되어 있음.
`init()` -> `doFilter()` -> `destory()` 실행 순서가 결정되어 있다.

```java
public interface Filter {

    public default void init(FilterConfig filterConfig) throws ServletException {}

    public void doFilter(ServletRequest request, ServletResponse response,
            FilterChain chain) throws IOException, ServletException;

    public default void destroy() {}
}
```

method에 final이 붙으면 override 할 수 없다.

```java
public abstract class AbstractProcessor {

    public final void process() {
        preProcess();
        mainProcess();
        postProcess();
    }

    protected abstract void preProcess();
    protected abstract void mainProcess();
    protected abstract void postProcess();
}
```

```java
public class ConsoleLogProcessor extends AbstractProcessor {

    @Override
    protected void preProcess() {
        System.out.println("preProcess");
    }

    @Override
    protected void mainProcess() {
        System.out.println("mainProcess");
    }

    @Override
    protected void postProcess() {
        System.out.println("postProcess");
    }
}
```

실행의 흐름은 AbstarctProcessor에 의해 제어가 된다.

필터도.. 톰캣도 템플릿 메서드 패턴

스프링프레임워크에서는 Application Context를 제공해준다.

Spring IoC Container
bean 생성 설정 조립하는 역할을 가지고 있다. 설정 메타데이터를 읽어 들임.

POJO, Configuration Metadata 스프링 컨테이너에 박아줌.

스프링 빈
스프링 IOC CONTAINER에 의해 관리(초기화, 조립, 관리)되는 자바 객체

name, type, object로 구성되어 있다.
Spring Framework에서 중요하게 관리하는 객체로 이해

자바 빈 vs 스프링 빈
자바빈은 스프링빈이 될 수 있음. 그 반대는 안됨.
스프링빈은 POJO에 의해

자바빈이 될ㄹ려면?
default 생성자 있어야함
getter/setter 필요
Serializable 필요

Spring IoC container = { Bean Factory | ApplicationContext } 둘 중 뭐가 될수도 있다.

<img src="https://nhnent.dooray.com/plantuml/img/TOr13e9034NtFKKlm0tS88ahBr66IXh6Tj8fKQFU7UB2a8ZR_zz_lqwYXPoks5EQHhTPXywoEOQJrhLY3H0DzWibnYEJdYY5-GEVyDuqPwb1VUR_H5jAbaGXffsjwJq-06mNU7WrWzsqsVF1tiTtyAk71G00">

bin factory는 api를 제공하는데. 스프링 ioc 의 기본적인 기능을제공

ApplicationContext

Beanfactory + alpha

<!-- 블로그 믿지마라. 틀린말 줫나많으니까 잘 판단해라!!! -->

언어에 관련된 것을 i 18n.. (internationalization)

event 쏘고 받을 수 있는 것...

애플리케이션을 개발할 때 항상 왜 ?  왜 ? 왜?  라고 고민을 하자

Appplication Context
`central interface`이다. 스프링 애플리케이션의 정보를 제공

1. 빈을 생성할 수 있는 관리할 수 있는 조립할 수 있는 빈 팩토리 메서드를 제공
2. 리소스에서 파일 로딩
3. 이벤트를 발생(트랜잭션이 끝났다!)
4. `message`를 resolving
5. parent conetxt 부터 상속.

<img src="https://nhnent.dooray.com/share/tree/zbJkAsWKRWiiLFiAxI7Jtw/pages/3213966097066225877/attach-files/3214645016722325995">

~xml~ApplicationContext
~AnnotationConfig ~ApplcationContext
...

외부 파일은 `src/main/resources`에 둔다 ..

beans.xml 생성

spring bean은 name, type, object 이 세가지를 가지고 있다. 가지고 있따. 기억

```java
try (ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("beans.xml"))
```

싱글톤 3가지 방법
dcl classLoader lazyloading

스프링 애플리케이션에서 xml에 등록하는건 다 싱글톤

엄밀히 말하면 applciation context 내에서 싱글톤

eqauls 찍어봐도 hash code가 같기 때문에 true가 반환된다.

싱글톤 말고 prototype 으로 하고 싶으면 `scope = "prototype"`으로 주면 된다.

예시로 stdout 찍어보면
prototype으로 scope를 주면 initiate()가 발생하면서 객체가 생성이 되는 것을 알 수가 있다.
그러나 default ( singleton )으로 주면 처음 단 한번만 생성하는 싱글톤의 특성답게 처음 한번만 initiate()하는 것을 알 수가 있다.

ClassPathXmlApplicationContext 가 죽을때 Singleton 죽음

싱글톤으로 만들었을 때 주의할 점은? `state`를 가지면 안된다. thread-safe 하게 작성해야 한다.

prototype은 ?
...

객체의 생명주기 callbacks 초기화
InitiliziingBean 인터페이스를 구현한 빈은 생성시에 초기화 작업을 할 수 있다.

아주 엄밀하게 말하면 pojo가 아님
이 방식은 스프링프레임워크의 의존성이 발생함으로 권장하지 않는다.

xml 빈설정에서 `init-method="메소드 이름"` 을 지정해서 초기화 작업을 진행할 수 있다.

이런 작업을 언제하느냐? pool을 만들때 한다. http connection pool thread pool...
런타임시 실행을 했을 때 비용이 큰 것들. 앱이 올라갔을때 풀을 만들어 놓으면 실행시간이 짧아진다.

스프링빈 : 컨테이너에 의해 관리

생성자 - init-method .. - 아하

`풀`은 사용할 때 획득한 메모리와 나중에 해제되는 메모리가 아닌, 사용할 준비가 된 메모리에 유지되는 리소스 모음

풀에 객체를 가둬놓고 .. thread가 될 수도 있고, db connection가 될 수도 있고,... tcp conneciton이 될수도 있고 pool에서 이미 만들어진 객체를 만들 수 있음. borrow()라는 메소드로 가져올 수 있음. 나중에 쓰고 반납해야함. 이런 개념을 가진것을 pool이라 한다 ...
이런 것들을 new 해서 인스턴스화를 하는 것이 비용(cpu power, time ...)이 비싸기 때문에 리눅스에서 스레드를 생성하면 os가 스레드가 생성이 되기 때문에 ...
그러니까 스프링에서 자주 쓰는 친구들(pool) 한테 이러한 것들을 빌리고 반납하면 비용을 아낄 수 있다.

개발자를 하는 순간 배우는 것을 부끄러워하지 마세요.

싱글톤으로 생성한 빈에 destory() 호출하는 시점? cleanup을 한 후 내려간다!
프로토타입으로 생성하면 .. 언제 cleanup을 할지 명확하지 않아요. GC에 의해 종료됨. GC는 destory 메소드를 호출해주지 않아요 호출되는 시점이 사실상 없다.

모든 스프링 빈..에 init을 해줘.. or destory를 해줘 .. 라고 할 수도 있음
그러면 앞에 default를 붙여주면 됩니다.

BeanPostProcessor(Interface)
Spring IOC의 생명주기 처리를 변경할 수 있는 확장 포인트
BeanPostProcessor가 설정되면 Bean 생명주기 이벤트를 가로채기 처리할 수 있다...

BeanPostProcessor .. 초기화 전 후 처리
상속받아 메소드를 처리해주면 됩니다.

모든 스프링 프로젝트는 스프링 컨텍스트 안에 있어야 한다.
그러므로 `beans.xml` 안에 넣는다.

그러면 application context 들어갈 떄 BeanPostPrcoess를 구현한 친구를 등록하면 .. !
생성 전후로 개입이된다. good

만약에 init 메서드를 beans.xml 에 정의하고 BeanPostProcessor 를 정의를 하면?
어떤 녀석이 먼저 찍힐까요

의존성? ... 의존하는 스프링빈이 있을것이고 의존해주는 스프링빈이 있을것인데 ..?
어떻게 java config로 바꾸나요?
