## 스프링 프레임워크

- 2개 이상의 컴포넌트로 이루어진 것을 엔터프라이즈 애플리케이션이라 한다.
- 스프링 프레임워크는 엔터프라이즈 애플리케이션을 위한 프레임워크이다.

<div align="center">
<img src="https://user-images.githubusercontent.com/97272787/230861741-7592bacc-f011-4c8b-bee1-448d4884d8db.png">
</div>

### 프레임워크 vs 라이브러리

- 주도권의 차이!

- `프레임워크`는 내 코드를 호출(내가 호출 당하는 것)
- `라이브러리`는 내가 주도해서 라이브러리를 호출하는 것

- 공통점
  - 특정 문제를 일반적인 방법으로 해결하기 위한 코드를 제공
  - 재활용할 수 있다.

- 차이점
  - framework는 원하는 기능을 구현하기 위하여 일정한 형태를 제공(SRPING MVC는 URI를 파싱하는 메서드 제공 ... 등)

<br/>

- 프레임워크는 기능적 요구사항과 비기능적 요구사항을 관리할 수 있음
  - `기능적 요구사항` : 메일을 보낼 수 있어야한다. 로그인을 할 수 있어야한다. 사용자가 실질적으로 다룰 수 있는(사용자가 볼 수 있는)
  - `비기능적 요구사항` : 사용자가 볼 수 없는...(RDB 트랜잭션) 사용자는 볼 수 없지만, 무조건 들어가야 하는 http 프로토콜 .. 등등

자바로 하면 대부분 스프링... 디팩토(de facto.. 사실상 표준 뜻이다.)

<br/>

#### 스프링이 창궐하기 전에는

과거 EJB를 썼음 EJB 는 ?

1. 느림
2. 프레임워크의 제공해주는 코드의 의존이 너무 강하다.(interusive........)

#### 스프링은 EJB에 비해서

1. lightweight(EJB에 비해서)
2. 내가 필요한 기능만 딱 떼다가 쓰기 좋음.(modular..)
3. 순수 자바로만 개발할 수 있음.(POJO, Plain Old Java Object) (3.0 애너테이션 이후로는..? 아닐수도)

### POJO(Plain Old Java Object)

`POJO`는 말 그대로 해석을 하면 오래된 방식의 간단한 자바 오브젝트라는 말로서 Java EE 등의 무거운 프레임워크들을 사용하게 되면서 해당 프레임워크에 종속된 무거운 객체를 만들게 된 것에 반발해서 사용하게 된 용어!
토비의 스프링에서는 `진정한 POJO란` 객체지향적인 원리에 충실하면서, 환경과 기술에 종속되지 않고 필요에 따라 재활용 될 수 있는 설계된 오브젝트이다!.

POJO 라는 용어는 이후에 주로 특정 자바 모델이나 기능, 프레임워크 등을 따르지 않은 자바 오브젝트를 지칭하는 말로 사용되었다. 스프링 프레임워크 또한 POJO 방식의 프레임워크이다.

#### 정의

이상적으로, POJO는 자바 언어 사양 외에 어떠한 제한에도 묶이지 않은 자바 오브젝트라 할 수 있다. 이를테면 POJO는 다음과 같은 행동을 해선 안된다.

1. 미리 정의된 클래스 확장

```java
public class Foo extends javax.servlet.http.HttpServlet { ... }
```

2. 미리 정의된 인터페이스의 구현

```java
public class Bar extends javax.ejb.EntityBean { ... }
```

3. 미리 정의된 애너테이션을 포함

```java
@javax.persistence.Entity public class Baz { ... }
```

### SpringFramework의 특징

1. `경량 컨테이너`, `Spring Bean을 직접관리`
꼬리에 꼬리를 무는 SpringBean.. : 스프링컨테이너에 의해 관리받는 자바 객체(일반적으로)

- 스프링 빈의 객체의 라이프 사이클을 관리한다.(라이프 사이클 ? 일반적으로 new를 사용해서 인스턴스 생성 - 호출 - 더 이상의 레퍼런스가 없을 때 GC에 의해 소멸되는)

- 자바 빈 객체의 생성, 보관, 제거에 관한 모든일을 처리

2. POJO 기반

- 일반적인 J2EE 프레임워크와 비교해서, 특정 인터페이스를 구현하고 상속받을 필요가 없다.
- 기본 라이브러리를 사용하기 편함

3. 제어 역전(IoC, InversionOfControl)

- 컨트롤의 `제어권이 사용자가 아니라 프레임워크에 있다`. 필요에 따라 Spring이 사용자의 코드를 호출
- IoC를 컨트롤 하기위해 DI(의존성 주입)이라는 방식으로 개발되어 있다.
- 스프링 프레임워크는 DDD, TDD를 기반으로 만들어진 프레임워크이다.(DDD, TDD를 사용하기에 매우 적합하다. Service, Controller ... etc)

4.관점 지향 프로그래밍(AOP) 지원

- 프로그래밍의 패러다임 : 프로그래밍의 패러다임은 객체지향, 함수형 딱 2가지로 볼 수 있다.
- 관점지향은 새로운 패러다임이 아니라, 객체 지향 프로그래밍을 다른 방법으로 풀어놓은 것이라 할 수 있다. 프로그래밍 관점에서 보면 비기능적에서 연관이 있다.
  - RDB에 관점에서 보면 트랜젝선 시작과 종료가 있어야된다.
  - 성능측정하는 애플리케이션의 관점에서 봤을 때는 쓰레드의 시작과 종료의 시간을 구해서 얼마나 시간이 걸렸는지 궁금하다.
  - 보안의 관점에서 봤을대 어떤 http call을 했을 떄 비즈니스 로직 시작전 인증 인가가 되어 있어야 된다.
- 이런 관점들은 사용자들 입장에선 별로 중요한게 아니다. 그러나 개발자 입장에서는 공통적으로 필요한 것들이다.
- 예를 들어, 쿼리를 시작하기 전에 transaction begin .. 정상적으로 끝나면 commit .. 에러가 발생했을 떄는 롤백해야한다는 로직을 따라야 한다.

5. 영속성 지원

- 영원히 저장하는 메모리 객체 데이터 수정. 메모리에 무언가를 적어 놓으면 애플리케이션 종료하면 메모리 날라간다.
- 우리가 DB에다 적거나 파일에다 적거나 일반적으로 이런것들을 영속적으로 저장한다 라고 함.
- 일반적으로 영속성이라 하는것은 db에 저장하고 읽어오는 과정을 영속성이라 한다.
- 생각해보면 모든 애플리케이션의 기능은 데이터 저장 수정, ... 어떻게 하면 효율적으로 저장하고 읽고 수정하는 것에 포커스가 맞춰져있음.
  - mybatis, hibernate(jpa 표준의 구현체), jdbc, jpa

6. 한국의 Spring Framework

전자정부 표준 프레임워크? 이걸 안쓰면 납품이안됨. `정지범 수석`님이 doc을 썼다고 함. 아버지? 라고하네

7. Spring Framework Modules

- 코어는 다 들어가니까 무조건 알아라

1. Spring-core : 핵심유틸리티포함
2. Spring-context : bean-factory, ioc-container 등 .. Application-Context이다. 이거 없이는 스프링이 안돌아간다.
3. Spring-context-support : third-part 라이브러리를 통합된. 쿼츠 구아바 등
4. Spring-beans : Spring bean과 관련된 애너테이션
5. Spring-expression : SPEL관련 기능. value라는 애너테이션을 쓰면 이걸 쓰게 된다.

8. Spring AOP

1. spring-aop : ...
2. spring-aspects : ..

9. data/영속성.. 관련
1.spring jdbc : 자바에선 무조건 jdbc연관 디비관련이면
2.spring test : 클래스 두개 이상이라면 큰 기능 : integration test 가상의 디비나 저장소를 사용해서 .. unit test는 클래스 하나
3. spring tx : 트랜잭션
4. spring web , web-mvc : http 기술들을 다루는 친구들

### 스프링 프로젝트

- 스프링부트
- 스프링
- 스프링데이터 : jpa, redis, mongodb, etc......
- 스프링 배치 : 배치 프로그램? 일련의 작업들을 작업 단위로 묶어 연속적으로 일괄 처리하는 것.(은행, 하루에 얼마나 입금이 됐나. 출금이 얼마나 됏나 . 배치 프로그램으로 일괄처리). 인증? 유저를 확인하는 절차(로그인) 인가? 로그인 한 사람의 권한 등급을 확인하면서 권한을 부여하는 작업(인가) spring security.
- 스프링 amqp : 메시지 큐라고 하는 그 내용을 표준 프로토콜로 정의 해놓은 것이 amqp

#### 스프링 부트 vs 스프링 코어?

스프링 부트는 기본설정만 하면 바로 개발할 수 있음. 내장 톰캣 .. 버전 관리 ..

`스프링 코어`는  일일이 하나하나 올려야한다.
`스프링 부트`는 이미 만들어진 것을 부트에서 가이드하는것을 따라만 하면 동작! 굿
스프링코어 랑 부트는 달라요! 라고 하는 말은 무시하면됨. 스프링 부트는 스프링 코어를 의존하고 있어 다르다고 할 수 없다!

### 스프링 트라이앵글

1. `DI`
2. `AOP`
3. `PSA`

`POJO`를 중심으로 자바 클래스를 작성하면 되고, 이 자바 클래스를 3가지가 도와줘서 스프링 프레임워크가 된다.!!

<div align="center">
<img src="https://user-images.githubusercontent.com/97272787/230867096-66569614-a648-4468-bb37-4493f80a1cb1.png">
</div>

#### 수업방식?

- di aop psa 를 기준으러 어떻게 적용하는지. 하루종일 한다
- 다형성이 뭐에요
- 추상화가 뭐에요
- 이런식으로 꼬리질문 ...

<br/>

- 추상화란 ? 어떤 클래스가 어떤 기능을 하는지 공통적을 뽑아낸 것.

자바 시작? `manifest.md`

### 스프링에서 IOC란 무엇인가요

- 프레임워크는 나의 코드를 호출, 라이브러리는 내가 호출
- 제어권을 프레임워크가 갖는 것.(IoC)


- 스프링 빈은 new 키워드를 써서 객체를 생성하지 않음. `beans.xml` ... 에
이 클래스가 스프링 빈이 될거야 라고 설정을 합니다. `<bean id="..." class="org.exmaple. ~" />`

- 코드 작성도 프레임워크가 하는대로... 객체 생성도 프레임워크가... 개발자는 프레임워크가 하라는대로 한다

- 프레임워크는 이 설정을 보고 객체를 생성하고, 코드가 동작하는 순서를 결정하여 실행

```java
public class Main {
    public static void main(String[] args) {
        SmsMessageSender smsMessageSender = new SmsMessageSender(); // 얘부터 생성하자. 그런데, 스프링 프레임워크는 알고 있다. 이 순서를 그래서 알아서 잡아줌.
        MessageSendService messageSendService = new MessageSendService(smsMessageSender); // 스프링 프레임워크는 객체를 실행하는 순서를 결정해서 실행한다. 순환 참조되면 exception 떠버림.
        messageSendService.doSendMessage(); // 그래서 실행 못하게함.
    }
}
```
#### 이 원칙을 헐리우드 원칙이라고도 한다.

#### 프레임워크와 라이브러리의 차이점이 뭔가요 ?
가장 큰 차이점은 제어권입니다. 프레임워크는 제어권이 프레임워크가 가지고 있고, 라이브러리는 개발자가 제어권을 가지고 있습니다.
이와 연관된 말로는 IoC가 있다.

#### 예시 ) 템플릿 메서드 패턴

template 으로 존재하는 method + pattern
추상 클래스에 템플릿에 해당하는 메소드에서 실행의 흐름이 이미 결정되어있음.

템플릿 메서드 패턴의 가장 큰 예시로는 `template method pattern`이 있다. 이미 추상 클래스에 템플릿에 해당하는 메소드에서 실행의 흐름이 이미 결정되어 있음.
`init()` -> `doFilter()` -> `destory()` 실행 순서가 결정되어 있다.

```java
public interface Filter {

    public default void init(FilterConfig filterConfig) throws ServletException {}

    public void doFilter(ServletRequest request, ServletResponse response,
            FilterChain chain) throws IOException, ServletException;

    public default void destroy() {}
}
```

method에 final이 붙으면 override 할 수 없다.

```java
public abstract class AbstractProcessor {

    public final void process() {
        preProcess();
        mainProcess();
        postProcess();
    }

    protected abstract void preProcess();
    protected abstract void mainProcess();
    protected abstract void postProcess();
}
```

```java
public class ConsoleLogProcessor extends AbstractProcessor {

    @Override
    protected void preProcess() {
        System.out.println("preProcess");
    }

    @Override
    protected void mainProcess() {
        System.out.println("mainProcess");
    }

    @Override
    protected void postProcess() {
        System.out.println("postProcess");
    }
}
```

- 실행의 흐름은 `AbstarctProcessor에 의해 제어`가 된다. 다형성을 떠올리자.

- 필터도.. 톰캣도 템플릿 메서드 패턴

- 스프링 프레임워크에서는 `Application Context`를 제공해준다.

`Spring IoC Container`
bean 생성 설정 조립하는 역할을 가지고 있다. 설정 메타데이터를 읽어 들임.

`POJO`, Configuration Metadata 스프링 컨테이너에 박아줌.

`스프링 빈`
스프링 IoC CONTAINER에 의해 관리(초기화, 조립, 관리)되는 자바 객체

`name`, `type`, `objec`t로 구성되어 있다.
Spring Framework에서 중요하게 관리하는 객체로 이해

`자바 빈 vs 스프링 빈`
자바빈은 스프링빈이 될 수 있음. 그 반대는 안됨.
스프링빈은 POJO다.

#### 자바 빈이 될려면?

`default` 생성자 있어야함 `getter/setter` 필요 `Serializable` 필요

Spring IoC container = { Bean Factory | ApplicationContext } 둘 중 뭐가 될수도 있다.

<div align="center">
  <img src="https://user-images.githubusercontent.com/97272787/230868242-167f254e-0628-41e2-9232-35a0c68e255d.png">
</div>

bin factory는 api를 제공하는데. 스프링 ioc 의 기본적인 기능을제공

ApplicationContext

Beanfactory + alpha

<!-- 블로그 믿지마라. 틀린말 줫나많으니까 잘 판단해라!!! -->

언어에 관련된 것을 i 18n.. (internationalization)

event 쏘고 받을 수 있는 것...

#### Application Context

- 스프링 애플리케이션 전반에 걸쳐 모든 구성요소의 `제어 작업을 담당`하는 `IoC 엔진` . IoC 방식을 따라 만들어진 일종의 빈 팩토리

- `Central Interface`이다. 스프링 애플리케이션의 정보를 제공

- `Central Interface`는 중앙 인터페이스를 의미합니다. 다른 시스템이나 장치와 통신하고 데이터를 전송하는 데 사용하는 중앙 제어 시스템 또는 프로그램을 말합니다. 보통 중앙 제어 시스템은 여러 개의 하위 시스템이나 장치를 통합하여 관리하기 위해 사용됩니다. 예를 들어, 공장에서는 중앙 제어 시스템을 사용하여 여러 공정과 장비를 통합적으로 제어하고 모니터링할 수 있습니다. 또한, 건물 관리 시스템에서도 중앙 제어 시스템을 사용하여 불편한 작업을 최소화하고, 효과적인 상황 대처가 가능합니다.

1. 빈을 생성할 수 있는 관리할 수 있는 조립할 수 있는 빈 팩토리 메서드를 제공
2. 리소스에서 파일 로딩
3. 이벤트를 발생(트랜잭션이 끝났다!)
4. `message`를 resolving
5. parent conetxt 부터 상속.

<img src="https://nhnent.dooray.com/share/tree/zbJkAsWKRWiiLFiAxI7Jtw/pages/3213966097066225877/attach-files/3214645016722325995">

~xml~ApplicationContext
~AnnotationConfig ~ApplcationContext
...

외부 파일은 `src/main/resources`에 둔다 ..

### beans.xml 생성

spring bean은 name, type, object 이 세가지를 가지고 있다. 가지고 있다. 반복 기억

```java
try (ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("beans.xml"))
```

싱글톤 3가지 방법
dcl classLoader lazyloading

#### 스프링 애플리케이션에서 xml에 등록하는건 다 싱글톤

- 엄밀히 말하면 `applciation context` 내에서 싱글톤

- eqauls 찍어봐도 hash code가 같기 때문에 true가 반환된다.

- 싱글톤 말고 prototype 으로 하고 싶으면 `scope = "prototype"`으로 주면 된다.

- 예시로 stdout 찍어보면
prototype으로 scope를 주면 initiate()가 발생하면서 객체가 생성이 되는 것을 알 수가 있다.
그러나 default ( singleton )으로 주면 처음 단 한번만 생성하는 싱글톤의 특성답게 처음 한번만 initiate()하는 것을 알 수가 있다.

#### 생명주기 ?

- ClassPathXmlApplicationContext 가 죽을때 Singleton 죽음

- 싱글톤으로 만들었을 때 주의할 점은? `state`를 가지면 안된다. thread-safe 하게 작성해야 한다.

- prototype은 ? 뒤지는 시기가 애매해.
...

객체의 생명주기

#### callbacks 초기화

InitiliziingBean 인터페이스를 구현한 빈은 생성시에 초기화 작업을 할 수 있다.

- 아주 엄밀하게 말하면 pojo 방식이라 하기 애매해.
- 이 방식은 스프링프레임워크의 의존성이 발생함으로 권장하지 않는다. 그러나 쓸 데가 있다. 초기화 작업?

- xml 빈설정에서 `init-method="메소드 이름"` 을 지정해서 초기화 작업을 진행할 수 있다.

- 이런 작업을 언제하느냐? pool을 만들때 한다. http connection pool thread pool... 런타임시 실행을 했을 때 비용이 큰 것들. 앱이 올라갔을때 풀을 만들어 놓으면 실행시간이 짧아진다.

- 스프링빈 : 컨테이너에 의해 관리

생성자 - init-method .. - 아하

#### 풀(Pool)?

- `풀`은 사용할 때 획득한 메모리와 나중에 해제되는 메모리가 아닌, 사용할 준비가 된 메모리에 유지되는 리소스 모음

- 풀에 객체를 가둬놓고 .. thread가 될 수도 있고, db connection가 될 수도 있고,... tcp conneciton이 될수도 있고 pool에서 이미 만들어진 객체를 만들 수 있음. borrow()라는 메소드로 가져올 수 있음. 나중에 쓰고 반납해야함. 이런 개념을 가진것을 pool이라 한다 ...
이런 것들을 new 해서 인스턴스화를 하는 것이 비용(cpu power, time ...)이 비싸기 때문에 리눅스에서 스레드를 생성하면 os가 스레드가 생성이 되기 때문에 ...
그러니까 스프링에서 자주 쓰는 친구들(pool) 한테 이러한 것들을 빌리고 반납하면 비용을 아낄 수 있다.

- 싱글톤으로 생성한 빈에 destory() 호출하는 시점? cleanup을 한 후 내려간다!
- 프로토타입으로 생성하면 .. 언제 cleanup을 할지 명확하지 않음.
- GC에 의해 종료되는데, GC는 destory 메소드를 호출해주지 않아요 호출되는 시점이 사실상 없어서 죽는 시기가 애매하다.

- 모든 스프링 빈..에 init을 해줘.. or destory를 해줘 .. 라고 할 수도 있음
그러면 앞에 default를 붙여주면 됩니다.

#### `BeanPostProcessor`(Interface)
Spring IOC의 생명주기 처리를 변경할 수 있는 확장 포인트
BeanPostProcessor가 설정되면 Bean 생명주기 이벤트를 가로채기 처리할 수 있다...

BeanPostProcessor .. 초기화 전 후 처리
상속받아 메소드를 처리해주면 됩니다.

모든 스프링 프로젝트는 스프링 컨텍스트 안에 있어야 한다.
그러므로 `beans.xml` 안에 넣는다.

그러면 application context 들어갈 떄 BeanPostPrcoess를 구현한 친구를 등록하면 .. !
생성 전후로 개입이된다. good

만약에 init 메서드를 beans.xml 에 정의하고 BeanPostProcessor 를 정의를 하면?
어떤 녀석이 먼저 찍힐까요

의존성? ... 의존하는 스프링빈이 있을것이고 의존해주는 스프링빈이 있을것인데 ..?
어떻게 java config로 바꾸나요?
